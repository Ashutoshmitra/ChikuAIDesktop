<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chiku AI Desktop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f9fafb;
            color: #1f2937;
            margin: 0;
            padding: 0;
            overflow: hidden;
            border-radius: 12px;
        }

        body.interview-mode {
            background: transparent;
        }

        .login-container {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-app-region: drag;
            position: relative;
        }
        
        .login-header-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            -webkit-app-region: no-drag;
        }
        
        .login-collapse-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .login-collapse-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        #loginScreen {
            display: block;
        }

        #dashboard {
            display: none;
        }

        .container {
            text-align: center;
            padding: 40px;
            max-width: 320px;
            width: 100%;
        }

        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border-radius: 12px;
            background-image: url('hero_image.png');
            background-size: cover;
            background-position: center;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .subtitle {
            color: #6b7280;
            margin-bottom: 40px;
            font-size: 14px;
        }

        .login-btn {
            width: 100%;
            background: #c8894a;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-app-region: no-drag;
        }

        .login-btn:hover {
            background: #b87c42;
        }

        .login-btn:active {
            transform: translateY(0);
        }

        .loading {
            display: none;
            margin-top: 20px;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #c8894a;
            border-radius: 50%;
            margin: 0 auto;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .dashboard {
            background: #f9fafb;
            color: #1f2937;
            overflow: hidden;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            -webkit-app-region: drag;
            border-radius: 12px 12px 0 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-small {
            width: 32px;
            height: 32px;
            background: url('hero_image.png') center/cover;
            border-radius: 6px;
        }

        .app-name {
            font-weight: 700;
            font-size: 16px;
            color: #1f2937;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 4px;
            -webkit-app-region: no-drag;
        }

        .credits-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #374151;
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .header-cooldown-timer {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #fbbf24;
            font-size: 11px;
            margin-left: 4px;
            display: none;
        }
        
        .header-cooldown-timer.show {
            display: inline;
        }

        .credits-icon {
            width: 12px;
            height: 12px;
            background: #fbbf24;
            border-radius: 50%;
            position: relative;
        }

        .credits-icon::after {
            content: '$';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8px;
            font-weight: bold;
            color: #1f2937;
        }

        .menu-btn {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 16px;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .menu-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .collapse-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .collapse-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .menu-dropdown {
            display: none;
            position: absolute;
            right: 16px;
            top: 50px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 100;
            min-width: 200px;
        }

        .menu-dropdown.show {
            display: block;
        }

        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #374151;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #f9fafb;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            -webkit-app-region: no-drag;
        }

        .tabs {
            display: flex;
            background: white;
            border-bottom: 1px solid #e5e7eb;
        }

        .tab {
            flex: 1;
            padding: 16px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #374151;
        }

        .tab.active {
            color: #1f2937;
            border-bottom-color: #c8894a;
        }

        .tab-content {
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .session-type-label {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 16px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .info-icon {
            width: 16px;
            height: 16px;
            background: #9ca3af;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
        }

        .session-options {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .session-option {
            flex: 1;
            padding: 12px 16px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: center;
            font-weight: 500;
        }

        .session-option:hover {
            border-color: #c8894a;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .session-option.disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
            border-color: #d1d5db;
        }

        .session-option.disabled:hover {
            border-color: #d1d5db;
            box-shadow: none;
        }

        .buy-credits-btn {
            flex: 1;
            background: #374151;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .buy-credits-btn:hover {
            background: #1f2937;
        }

        .sessions-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            overflow-y: auto;
        }

        .session-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            transition: all 0.2s;
        }

        .session-item:hover {
            border-color: #d1d5db;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .session-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .session-avatar {
            width: 32px;
            height: 32px;
            background: #f3f4f6;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #6b7280;
            font-size: 14px;
        }

        .session-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .session-language {
            background: #374151;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .session-status {
            font-size: 12px;
            color: #6b7280;
        }

        .session-date {
            font-size: 12px;
            color: #9ca3af;
        }

        .view-all {
            text-align: center;
            margin-top: 16px;
        }

        .view-all-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
            transition: color 0.2s;
        }

        .view-all-btn:hover {
            color: #374151;
        }

        .features {
            margin-top: 30px;
            text-align: center;
        }

        .feature-item {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            font-size: 12px;
            color: #9ca3af;
        }

        .feature-item::before {
            content: "âœ“";
            color: #c8894a;
            margin-right: 8px;
            font-weight: bold;
        }

        /* Resume Selection Screen Styles */
        #resumeSelectionScreen {
            display: none;
            background: #f9fafb;
            flex-direction: column;
            border-radius: 12px;
        }

        .resume-screen-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            -webkit-app-region: drag;
            border-radius: 12px 12px 0 0;
        }

        .resume-screen-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }

        .close-btn {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .resume-header-controls,
        .activation-header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            -webkit-app-region: no-drag;
        }

        .resume-collapse-btn,
        .activation-collapse-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .resume-collapse-btn:hover,
        .activation-collapse-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .resume-screen-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 600px;
            margin: 0 auto;
            -webkit-app-region: no-drag;
            overflow-y: auto;
            max-height: calc(650px - 80px);
            width: 100%;
        }

        .resume-description {
            text-align: center;
            color: #6b7280;
            margin-bottom: 32px;
            font-size: 14px;
            line-height: 1.5;
        }

        .form-section {
            width: 100%;
            margin-bottom: 24px;
        }

        .form-row {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .form-group {
            flex: 1;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            color: #1f2937;
            background: white;
            transition: border-color 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: #c8894a;
            box-shadow: 0 0 0 3px rgba(200, 137, 74, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-input {
            width: 16px;
            height: 16px;
            accent-color: #c8894a;
        }

        .beta-badge {
            background: #fbbf24;
            color: #1f2937;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .checkbox-description {
            color: #6b7280;
            font-size: 12px;
            margin-left: 6px;
        }

        .resume-list-section {
            width: 100%;
            margin-bottom: 24px;
        }

        .no-resumes-state {
            text-align: center;
            padding: 16px 24px;
        }

        .no-resumes-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .no-resumes-title {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
        }

        .no-resumes-subtitle {
            color: #6b7280;
            font-size: 12px;
            margin-bottom: 12px;
        }

        .add-resume-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 16px 24px;
            background: white;
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            color: #6b7280;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .add-resume-btn:hover {
            border-color: #c8894a;
            color: #c8894a;
            background: #fffbf0;
        }

        .plus-icon {
            width: 20px;
            height: 20px;
            background: #9ca3af;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .add-resume-btn:hover .plus-icon {
            background: #c8894a;
        }

        .resume-item {
            display: flex;
            align-items: center;
            padding: 16px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .resume-item:hover {
            border-color: #c8894a;
            background: #fffbf0;
        }

        .resume-item.selected {
            border-color: #c8894a;
            background: #fffbf0;
        }

        .resume-radio {
            margin-right: 12px;
            accent-color: #c8894a;
        }

        .resume-info {
            flex: 1;
        }

        .resume-filename {
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .resume-details {
            font-size: 12px;
            color: #6b7280;
        }

        .continue-btn {
            width: 100%;
            max-width: 400px;
            padding: 16px 24px;
            background: #c8894a;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .continue-btn:hover {
            background: #b87c42;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 48px;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #e5e7eb;
            border-top: 3px solid #c8894a;
            border-radius: 50%;
            margin: 0 auto 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Session Activation Screen Styles */
        #sessionActivationScreen {
            display: none;
            background: #f9fafb;
            flex-direction: column;
            border-radius: 12px;
        }

        .activation-screen-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            -webkit-app-region: drag;
            border-radius: 12px 12px 0 0;
        }

        .activation-screen-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }

        .activation-screen-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            max-width: 400px;
            margin: 0 auto;
            -webkit-app-region: no-drag;
            width: 100%;
            text-align: center;
        }

        .session-info-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            width: 100%;
        }

        .session-timer-icon {
            width: 32px;
            height: 32px;
            background: #e5e7eb;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px;
            font-size: 16px;
        }

        .session-timer-text {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 6px;
        }

        .session-warning-text {
            font-size: 13px;
            color: #6b7280;
            line-height: 1.4;
            margin-bottom: 0;
        }

        .mock-interview-info {
            background: #f3f4f6;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
            text-align: left;
        }

        .mock-interview-title {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mock-interview-description {
            font-size: 13px;
            color: #6b7280;
            line-height: 1.4;
            margin-bottom: 12px;
        }

        .example-video-link {
            color: #c8894a;
            text-decoration: underline;
            font-size: 13px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .example-video-link:hover {
            color: #b87c42;
        }

        .activation-buttons {
            display: flex;
            gap: 12px;
            width: 100%;
        }

        .back-btn {
            flex: 1;
            padding: 12px 24px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            color: #374151;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .back-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        
        .header-back-btn {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-app-region: no-drag;
        }
        
        .header-back-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .header-close-btn {
            background: none;
            border: none;
            color: #dc2626;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-app-region: no-drag;
        }
        
        .header-close-btn:hover {
            background: #fef2f2;
            color: #991b1b;
        }

        .activate-btn {
            flex: 2;
            padding: 12px 24px;
            background: #c8894a;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .activate-btn:hover {
            background: #b87c42;
        }

        /* Interview Mode Overlay Styles */
        .interview-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            backdrop-filter: blur(10px);
            border-radius: 8px;
            overflow: hidden;
            z-index: 9999;
            flex-direction: column;
        }

        .interview-header {
            background: rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: move;
            -webkit-app-region: drag;
            border-radius: 8px 8px 0 0;
        }

        .interview-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            -webkit-app-region: no-drag;
        }

        .interview-header-center {
            color: white;
            font-size: 16px;
            font-weight: 600;
        }

        .interview-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            -webkit-app-region: no-drag;
            flex-wrap: nowrap;
        }

        .interview-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 90px;
            text-align: center;
            -webkit-app-region: no-drag;
        }

        .interview-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .interview-control-btn.active {
            background: #c8894a;
            border-color: #c8894a;
        }

        /* Status indicator buttons */
        .status-indicator-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            min-width: 50px;
            justify-content: center;
        }

        .status-indicator-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Active (ON) state - subtle green */
        .status-indicator-btn.active {
            background: rgba(34, 197, 94, 0.15);
            border-color: rgba(34, 197, 94, 0.3);
            color: rgba(34, 197, 94, 1);
        }

        .status-indicator-btn.active:hover {
            background: rgba(34, 197, 94, 0.2);
        }

        /* Inactive (OFF) state - subtle red */
        .status-indicator-btn.inactive {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
            color: rgba(239, 68, 68, 1);
        }

        .status-indicator-btn.inactive:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        /* Denied (PERMISSION DENIED) state - orange/amber */
        .status-indicator-btn.denied {
            background: rgba(245, 158, 11, 0.15);
            border-color: rgba(245, 158, 11, 0.3);
            color: rgba(245, 158, 11, 1);
        }

        .status-indicator-btn.denied:hover {
            background: rgba(245, 158, 11, 0.2);
        }

        .status-indicator-btn svg {
            width: 12px;
            height: 12px;
            stroke-width: 2;
        }

        .stop-session-btn {
            background: rgba(220, 38, 38, 0.8);
            border-color: rgba(220, 38, 38, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stop-session-btn:hover {
            background: rgba(220, 38, 38, 1);
        }

        .interview-collapse-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .interview-collapse-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .session-timer {
            color: white;
            font-size: 14px;
            font-weight: 600;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 90px;
            font-family: 'Courier New', monospace;
        }

        .interview-transcript-bar {
            background: rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            color: white;
            font-size: 13px;
            overflow: hidden;
            backdrop-filter: blur(5px);
            border-radius: 0 0 8px 8px;
        }
        
        .interview-transcript-display {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            overflow: hidden;
        }
        
        .transcript-label {
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            flex-shrink: 0;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }
        
        .transcript-text {
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            font-weight: 400;
            font-size: 13px;
            margin-left: 8px;
            transition: all 0.3s ease;
        }
        
        .interview-connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            font-size: 11px;
        }
        
        .interview-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }
        
        .interview-status-indicator.connecting {
            background: #f59e0b;
        }
        
        .interview-status-indicator.error {
            background: #ef4444;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Panel styles removed - using compact transcript bar now */

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* AI Response Area Styles */
        .interview-ai-response-area {
            background: rgba(0, 0, 0, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            max-height: 400px;
            overflow: hidden;
            transition: all 0.3s ease;
            border-radius: 0 0 8px 8px;
            position: relative;
        }
        
        .ai-response-header {
            background: rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .ai-response-title {
            color: white;
            font-size: 14px;
            font-weight: 600;
            margin: 0;
        }
        
        .ai-response-close-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            background: #000000;
            border: 1px solid #333333;
            color: #ffffff;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            font-size: 14px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-app-region: no-drag;
            text-align: center;
            line-height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .ai-response-close-btn:hover {
            background: #333333;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }
        
        .ai-response-content {
            padding: 16px 20px;
            max-height: 340px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
            color: white;
            word-wrap: break-word;
            text-align: left;
            box-sizing: border-box;
            width: 100%;
            position: relative;
        }
        
        .ai-response-content > div {
            margin-bottom: 12px;
        }
        
        .ai-response-content > div:last-child {
            margin-bottom: 0;
        }
        
        .ai-response-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .ai-response-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .ai-response-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.4);
            border-radius: 4px;
        }
        
        .ai-response-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.6);
        }
        
        /* AI Pagination Controls */
        .ai-pagination-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .ai-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .ai-nav-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .ai-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .ai-page-indicator {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 500;
            min-width: 50px;
            text-align: center;
        }
        
        
        .ai-loading {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }
        
        .ai-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .ai-markdown-content {
            line-height: 1.6;
            color: white;
            margin: 0;
            padding: 0;
            text-align: left;
            white-space: pre-wrap;
            width: 100%;
        }
        
        .ai-markdown-content h1,
        .ai-markdown-content h2,
        .ai-markdown-content .markdown-h1,
        .ai-markdown-content .markdown-h2 {
            color: #f59e0b;
            font-weight: 600;
            margin: 16px 0 8px 0;
        }
        
        .ai-markdown-content .code-block {
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
            position: relative;
            width: calc(100% - 24px);
        }
        
        .ai-markdown-content .code-block .language-label {
            position: absolute;
            top: 4px;
            right: 8px;
            background: rgba(200, 137, 74, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }
        
        .ai-markdown-content .inline-code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .ai-markdown-content strong {
            color: #fbbf24;
            font-weight: 600;
        }
        
        .ai-markdown-content em {
            color: #a7f3d0;
            font-style: italic;
        }
        
        .ai-markdown-content p {
            margin: 8px 0;
            text-align: left;
            width: 100%;
        }

        /* Panel content styles removed */

        .interview-panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .interview-panel-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .interview-panel-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .interview-chat-message {
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .interview-chat-message.ai-message {
            background: rgba(200, 137, 74, 0.2);
            border-left: 4px solid #c8894a;
        }

        .interview-chat-message.system-message {
            background: rgba(59, 130, 246, 0.2);
            border-left: 4px solid #3b82f6;
        }

        .interview-chat-message.user-message {
            background: rgba(34, 197, 94, 0.2);
            border-left: 4px solid #22c55e;
        }

        /* Chat Input Styling */
        .interview-chat-input-container {
            display: flex;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .interview-chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            font-size: 13px;
            font-family: system-ui, -apple-system, sans-serif;
            outline: none;
            transition: all 0.2s ease;
        }

        .interview-chat-input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #c8894a;
            box-shadow: 0 0 0 2px rgba(200, 137, 74, 0.2);
        }

        .interview-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .interview-chat-send-btn {
            background: #c8894a;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 60px;
        }

        .interview-chat-send-btn:hover {
            background: #b87c42;
            transform: translateY(-1px);
        }

        .interview-chat-send-btn:active {
            transform: translateY(0);
        }

        .interview-chat-send-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
        }

        /* Action Buttons Below Chat Input */
        .interview-action-buttons {
            display: flex;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.03);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .interview-action-btn {
            background: rgba(200, 137, 74, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            text-align: center;
            justify-content: center;
            -webkit-app-region: no-drag;
            white-space: nowrap;
        }

        .interview-action-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: #c8894a;
            transform: translateY(-1px);
        }

        .interview-action-btn:active {
            transform: translateY(0);
        }

        .interview-action-btn.active {
            background: #c8894a;
            border-color: #c8894a;
            box-shadow: 0 2px 8px rgba(200, 137, 74, 0.3);
        }

        .interview-action-btn:disabled {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }

        .interview-transcript-item {
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .interview-transcript-timestamp {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-family: 'Courier New', monospace;
            flex-shrink: 0;
            padding-top: 2px;
            min-width: 80px;
        }

        /* When right panel is collapsed, stack timestamp above text */
        /* Collapsed panel styles removed */

        .interview-transcript-text {
            color: white;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            word-wrap: break-word;
            overflow-wrap: anywhere;
        }

        .interview-transcript-partial {
            color: #60a5fa;
            font-style: italic;
            position: relative;
        }

        .interview-transcript-cursor {
            display: inline-block;
            width: 2px;
            height: 16px;
            background: #60a5fa;
            margin-left: 4px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .interview-connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 16px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
        }

        .interview-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .interview-status-indicator.connecting {
            background: #60a5fa;
        }

        .interview-status-indicator.connected {
            background: #22c55e;
        }

        .interview-status-indicator.error {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Transparency Controls */
        .transparency-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10000;
            min-width: 250px;
            justify-content: center;
        }

        .transparency-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }

        .transparency-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
        }

        .transparency-slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #c8894a;
            border: 2px solid white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .transparency-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #b87c42;
        }

        .transparency-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #c8894a;
            border: 2px solid white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .transparency-value {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 600;
            min-width: 30px;
            text-align: center;
        }

        .transparency-controls:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        /* Header Transparency Controls */
        .header-transparency-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-transparency-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        .header-transparency-slider {
            width: 80px;
            height: 3px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
        }

        .header-transparency-slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #c8894a;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .header-transparency-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #b87c42;
        }

        .header-transparency-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #c8894a;
            cursor: pointer;
            border: none;
        }

        .header-transparency-value {
            color: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            font-weight: 600;
            min-width: 30px;
            text-align: center;
        }

        /* Header Auto AI Toggle */
        .header-auto-ai-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-left: 12px;
        }

        .header-auto-ai-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        /* Auto AI Switch Styling */
        .auto-ai-switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
        }

        .auto-ai-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .auto-ai-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .auto-ai-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: all 0.3s ease;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .auto-ai-switch input:checked + .auto-ai-slider {
            background-color: #c8894a;
            border-color: #c8894a;
        }

        .auto-ai-switch input:checked + .auto-ai-slider:before {
            transform: translateX(16px);
            background-color: white;
        }

        .auto-ai-switch:hover .auto-ai-slider {
            background-color: rgba(200, 137, 74, 0.3);
        }

        .auto-ai-switch input:checked:hover + .auto-ai-slider {
            background-color: #b87c42;
        }

        /* Code Block Styling - Completely redesigned */
        .code-block-container {
            margin: 16px 0;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #3d4852;
            background: #1a1d23;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .code-block-header {
            background: #2d3748;
            color: #a0aec0;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #3d4852;
            font-family: system-ui, -apple-system, sans-serif;
        }

        .code-block {
            background: #1a1d23 !important;
            color: #e2e8f0 !important;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', 'Menlo', 'Consolas', monospace !important;
            font-size: 12px !important;
            line-height: 1.5 !important;
            padding: 12px 16px !important;
            margin: 0 !important;
            overflow-x: auto;
            white-space: pre;
            border: none !important;
            display: block !important;
            word-spacing: normal !important;
            word-break: normal !important;
            word-wrap: normal !important;
            tab-size: 4 !important;
        }

        .code-block code {
            background: transparent !important;
            color: inherit !important;
            font-family: inherit !important;
            font-size: inherit !important;
            padding: 0 !important;
            border: none !important;
            display: inline !important;
            white-space: pre !important;
            border-radius: 0 !important;
        }

        .inline-code {
            background: rgba(200, 137, 74, 0.15) !important;
            color: #d4af37 !important;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace !important;
            font-size: 11px !important;
            padding: 1px 4px !important;
            border-radius: 3px !important;
            border: 1px solid rgba(200, 137, 74, 0.25) !important;
            white-space: nowrap !important;
        }

        /* Improved syntax highlighting with better contrast */
        .code-block .keyword { 
            color: #f472b6 !important;
            font-weight: 500 !important;
        }
        
        .code-block .string { 
            color: #10b981 !important;
        }
        
        .code-block .comment { 
            color: #6b7280 !important; 
            font-style: italic !important;
        }
        
        .code-block .function { 
            color: #60a5fa !important;
            font-weight: 500 !important;
        }
        
        .code-block .class { 
            color: #f59e0b !important;
            font-weight: 500 !important;
        }

        /* Clean markdown styling */
        .markdown-h1 {
            color: #f59e0b !important;
            font-size: 16px !important;
            font-weight: 600 !important;
            margin: 16px 0 8px 0 !important;
            padding: 0 !important;
            border: none !important;
            display: block !important;
        }

        .markdown-h2 {
            color: #f59e0b !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            margin: 12px 0 6px 0 !important;
            padding: 0 !important;
            display: block !important;
        }

        .markdown-p {
            margin: 6px 0 !important;
            line-height: 1.5 !important;
            padding: 0 !important;
            display: block !important;
            color: inherit !important;
        }

        /* Cooldown notification styles */
        .cooldown-notification {
            background: #fbbf24;
            color: #1f2937;
            padding: 6px 12px;
            margin: 8px 20px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            display: none;
            align-items: center;
            gap: 6px;
            border: 1px solid #f59e0b;
            max-height: 40px;
        }

        .cooldown-notification.show {
            display: flex;
        }

        .cooldown-icon {
            font-size: 14px;
        }

        .cooldown-text {
            flex: 1;
        }

        .cooldown-timer {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            background: #1f2937;
            color: #fbbf24;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }

        .session-option.cooldown-disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
            border-color: #d1d5db;
            opacity: 0.6;
        }

        .session-option.cooldown-disabled:hover {
            border-color: #d1d5db;
            box-shadow: none;
        }


    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-container">
        <div class="login-header-controls">
            <button class="login-collapse-btn" onclick="collapseToLogo()" title="Minimize to logo">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M6 9l6 6 6-6"/>
                </svg>
            </button>
            <button class="header-close-btn" onclick="closeApp()" title="Close app">
                âœ•
            </button>
        </div>
        <div class="container">
            <div id="loginScreen">
                <div class="logo"></div>
                <h1>Chiku AI Desktop</h1>
                <p class="subtitle">Your AI Interview Assistant</p>
                
                <button class="login-btn" onclick="login()">
                    Login with Chiku AI
                </button>

                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p style="margin-top: 10px; font-size: 12px; color: #6b7280;">
                        Opening browser...
                    </p>
                </div>

                <div class="features">
                    <div class="feature-item">Screenshare protection</div>
                    <div class="feature-item">Customizable AI response</div>
                    <div class="feature-item">Screen Analyze Coding Assistance</div>
                </div>
                
                <!-- TEMPORARY DEBUG PANEL -->
                <div id="debugPanel" style="margin-top: 15px; padding: 10px; background: #f3f4f6; border-radius: 6px; font-size: 10px; text-align: left; max-width: 380px; margin-left: auto; margin-right: auto; word-wrap: break-word; overflow-wrap: break-word;">
                    <div style="font-weight: bold; margin-bottom: 6px; font-size: 11px;">ðŸ”§ Debug</div>
                    <div style="margin-bottom: 2px;">Status: <span id="updateStatus" style="color: #c8894a; font-weight: bold;">Checking...</span></div>
                    <div style="margin-bottom: 2px;">Ver: <span id="appVersion" style="color: #374151; font-weight: bold;">Loading...</span> | Check: <span id="lastCheck">Starting...</span></div>
                    <div id="updateInfo" style="margin: 6px 0; font-size: 9px; color: #666; min-height: 40px; max-height: 80px; overflow-y: auto; padding: 6px; background: #e5e7eb; border-radius: 3px; border: 1px solid #d1d5db;">
                        <div style="color: #999; font-style: italic;">Detailed info will appear here...</div>
                    </div>
                    <button onclick="manualUpdateCheck()" style="margin-top: 4px; padding: 4px 8px; font-size: 9px; background: #c8894a; color: white; border: none; border-radius: 3px; cursor: pointer; width: 100%; -webkit-app-region: no-drag;">Manual Check</button>
                    <button id="installUpdateBtn" onclick="installUpdate()" style="margin-top: 4px; padding: 4px 8px; font-size: 9px; background: #22c55e; color: white; border: none; border-radius: 3px; cursor: pointer; width: 100%; -webkit-app-region: no-drag; display: none;">Install Update Now</button>
                </div>
            </div>
        </div>
    </div>

        <!-- Dashboard Screen -->
        <div id="dashboard" class="dashboard">
            <div class="header">
                <div class="header-left">
                    <div class="logo-small"></div>
                    <span class="app-name">Chiku AI</span>
                </div>
                <div class="header-right">
                    <div class="credits-badge">
                        <div class="credits-icon"></div>
                        <span id="creditsCount">No Credits</span>
                        <span id="headerCooldownTimer" class="header-cooldown-timer"></span>
                    </div>
                    <button class="collapse-btn" onclick="collapseToLogo()" title="Minimize to logo">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M6 9l6 6 6-6"/>
                        </svg>
                    </button>
                    <button class="menu-btn" onclick="toggleMenu()">â‹¯</button>
                    <button class="header-close-btn" onclick="closeApp()" title="Close app">
                        âœ•
                    </button>
                    <div id="menuDropdown" class="menu-dropdown">
                        <div class="menu-item" id="userInfo">
                            <div style="width: 24px; height: 24px; background: #c8894a; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 12px;">U</div>
                            <div>
                                <div id="userName">User</div>
                                <div style="font-size: 12px; color: #6b7280;" id="userEmail">user@example.com</div>
                            </div>
                        </div>
                        <div class="menu-item" onclick="openDashboard()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/></svg>
                            <span>Dashboard</span>
                        </div>
                        <div class="menu-item" onclick="logout()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16,17 21,12 16,7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
                            <span>Logout</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="main-content">
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('create')">Create</button>
                    <button class="tab" onclick="switchTab('sessions')">Past Sessions</button>
                </div>

                <div class="tab-content">
                    <div id="createTab" class="tab-panel active">
                        <!-- Cooldown notification for free users -->
                        <div id="cooldownNotification" class="cooldown-notification">
                            <div class="cooldown-icon">â°</div>
                            <div class="cooldown-text">Free session cooldown active. Next session available in:</div>
                            <div class="cooldown-timer" id="cooldownTimer">--:--</div>
                        </div>
                        
                        <div class="session-type-label">
                            Select Session Type
                            <div class="info-icon">i</div>
                        </div>
                        <div class="session-options">
                            <div class="session-option" onclick="showFreeSession()">
                                Free Session
                            </div>
                            <button class="buy-credits-btn" id="actionBtn" onclick="handleActionButton()">
                                Buy Credits
                            </button>
                        </div>
                    </div>

                    <div id="sessionsTab" class="tab-panel">
                        <div class="sessions-list" id="sessionsList">
                            <!-- Sessions will be loaded here -->
                        </div>
                        <div class="view-all">
                            <button class="view-all-btn" onclick="viewAllSessions()">
                                View All â†’
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Resume Selection Screen -->
    <div id="resumeSelectionScreen">
        <div class="resume-screen-header">
            <div class="resume-header-left">
                <button class="header-back-btn" onclick="closeResumeSelection()" title="Go back">
                    â†
                </button>
            </div>
            <h1 class="resume-screen-title">Select Resume for Session</h1>
            <div class="resume-header-controls">
                <button class="resume-collapse-btn" onclick="collapseToLogo()" title="Minimize to logo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M6 9l6 6 6-6"/>
                    </svg>
                </button>
                <button class="header-close-btn" onclick="closeApp()" title="Close app">
                    âœ•
                </button>
            </div>
        </div>
        
        <div class="resume-screen-content">
            <p class="resume-description">
                Select a resume to help AI provide personalized answers based on your background and experience.
            </p>
            
            <!-- Company and Position Form -->
            <div class="form-section">
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label" for="companyInput">Company</label>
                        <input type="text" id="companyInput" class="form-input" placeholder="Demo Company" value="Demo Company">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="positionInput">Position</label>
                        <input type="text" id="positionInput" class="form-input" placeholder="Demo Position" value="Demo Position">
                    </div>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="autoAnswerCheckbox" class="checkbox-input">
                    <label for="autoAnswerCheckbox" class="form-label" style="margin-bottom: 0;">
                        Auto AI Answer
                        <span class="beta-badge">BETA</span>
                    </label>
                    <span class="checkbox-description">(Automatically detect and answer questions)</span>
                </div>
            </div>
            
            <!-- Resume List Section -->
            <div class="resume-list-section">
                <div id="loadingSpinner" class="loading-spinner">
                    <div class="spinner"></div>
                    <p style="color: #6b7280; font-size: 14px;">Loading resumes...</p>
                </div>
                
                <div id="resumesList"></div>
                
                <div id="noResumesState" class="no-resumes-state" style="display: none;">
                    <div class="no-resumes-icon">ðŸ“„</div>
                    <h3 class="no-resumes-title">No resumes found</h3>
                    <p class="no-resumes-subtitle">You can continue without selecting a resume.</p>
                </div>
                
                <button class="add-resume-btn" onclick="addNewResume()">
                    <div class="plus-icon">+</div>
                    <span>Manage resumes on web dashboard</span>
                </button>
            </div>
            
            <button class="continue-btn" onclick="continueWithResume()">
                Continue without Resume
            </button>
        </div>
    </div>

    <!-- Session Activation Screen -->
    <div id="sessionActivationScreen">
        <div class="activation-screen-header">
            <div class="activation-header-left">
                <button class="header-back-btn" onclick="backToResumeSelection()" title="Go back">
                    â†
                </button>
            </div>
            <h1 class="activation-screen-title">Activate Interview Session</h1>
            <div class="activation-header-controls">
                <button class="activation-collapse-btn" onclick="collapseToLogo()" title="Minimize to logo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M6 9l6 6 6-6"/>
                    </svg>
                </button>
                <button class="header-close-btn" onclick="closeApp()" title="Close app">
                    âœ•
                </button>
            </div>
        </div>
        
        <div class="activation-screen-content">
            <div class="session-info-card">
                <div class="session-timer-icon">â°</div>
                <div class="session-timer-text">This is a 10 minute free session.</div>
                <div class="session-warning-text">
                    You won't be able to create another free session for the next 12 minutes.
                </div>
            </div>
            
            <div class="mock-interview-info">
                <div class="mock-interview-title">
                    ðŸ“± Instead of an interview tab, you can also share a mock interview on YouTube and test Chiku AI that way.
                </div>
                <div class="mock-interview-description">
                    Example video: <span class="example-video-link" onclick="openExampleVideo()">Mock Interview</span>
                </div>
            </div>
            
            <div class="activation-buttons">
                <button class="activate-btn" id="activateButton" onclick="activateSession()">Activate (Free)</button>
            </div>
        </div>
    </div>

    <!-- Interview Mode Overlay -->
    <div class="interview-overlay" id="interviewOverlay">
        <div class="interview-header">
            <div class="interview-header-left">
                <div class="header-transparency-controls">
                    <span class="header-transparency-label">Opacity</span>
                    <input 
                        type="range" 
                        class="header-transparency-slider" 
                        id="transparencySlider"
                        min="10" 
                        max="100" 
                        value="95" 
                        oninput="updateTransparency(this.value)"
                    >
                    <span class="header-transparency-value" id="transparencyValue">95%</span>
                </div>
                <div class="header-auto-ai-toggle">
                    <span class="header-auto-ai-label">Auto AI</span>
                    <label class="auto-ai-switch">
                        <input type="checkbox" id="autoAIToggleInterview" onchange="toggleAutoAI(this.checked)">
                        <span class="auto-ai-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="interview-header-center">Chiku AI</div>
            
            <div class="interview-header-right">
                <!-- AI Action Buttons -->
                <button class="interview-action-btn" id="aiAnswerBtnInterview" onclick="handleAIAnswerInterview()" title="Get AI answer">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 12l2 2 4-4"></path>
                        <path d="M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                    </svg>
                    AI Answer
                </button>
                <button class="interview-action-btn" id="analyzeScreenBtnInterview" onclick="handleAnalyzeScreenInterview()" title="Analyze screen content">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                    Analyze Screen
                </button>
                
                <!-- Microphone Status Button -->
                <button class="status-indicator-btn" id="micStatusBtn" onclick="toggleMicrophone()" title="Toggle microphone">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2a4 4 0 0 0-4 4v6a4 4 0 0 0 8 0V6a4 4 0 0 0-4-4z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                    </svg>
                    <span id="micStatusText">OFF</span>
                </button>
                
                <!-- Screen Share Status Button -->
                <button class="status-indicator-btn" id="screenStatusBtn" onclick="toggleScreenShare()" title="Toggle screen share">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="4" width="20" height="12" rx="2"></rect>
                        <line x1="12" y1="16" x2="12" y2="20"></line>
                        <line x1="8" y1="20" x2="16" y2="20"></line>
                    </svg>
                    <span id="screenStatusText">OFF</span>
                </button>
                
                <button class="interview-collapse-btn" onclick="collapseToLogo()" title="Minimize to logo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M6 9l6 6 6-6"/>
                    </svg>
                </button>
                <button class="interview-control-btn stop-session-btn" id="stopSessionBtn" onclick="stopInterviewSession()">
                    <span>â– </span> Stop
                </button>
                <div class="session-timer" id="sessionTimerInterview">10:00</div>
            </div>
        </div>

        <!-- Compact Transcript Bar -->
        <div class="interview-transcript-bar">
            <div class="interview-connection-status" id="connectionStatus">
                <div class="interview-status-indicator connecting" id="statusIndicator"></div>
                <span id="statusText">Initializing...</span>
            </div>
            <div class="interview-transcript-display" id="interviewTranscriptDisplay">
                <span class="transcript-label">Latest:</span>
                <span class="transcript-text" id="latestTranscriptText">Waiting for speech...</span>
            </div>
        </div>

        <!-- Dynamic AI Response Area -->
        <div class="interview-ai-response-area" id="interviewAIResponseArea" style="display: none;">
            <div class="ai-response-close-btn" onclick="closeAIResponse()" title="Close AI response">â†‘</div>
            
            <!-- Pagination Controls -->
            <div class="ai-pagination-controls" id="aiPaginationControls" style="display: none;">
                <button class="ai-nav-btn" id="aiPrevBtn" onclick="navigateAIResponse(-1)" title="Previous response">â€¹</button>
                <span class="ai-page-indicator" id="aiPageIndicator">1 / 1</span>
                <button class="ai-nav-btn" id="aiNextBtn" onclick="navigateAIResponse(1)" title="Next response">â€º</button>
            </div>
            
            <div class="ai-response-content" id="aiResponseContent">
                <div class="ai-loading">
                    <div class="ai-loading-spinner"></div>
                    Processing your request...
                </div>
            </div>
        </div>

    </div>

    <script>
        // Polyfill for global
        if (typeof global === 'undefined') {
            var global = globalThis || window;
        }

        let isAuthenticated = false;
        let currentUser = null;
        let isInterviewModeInitializing = false;

        // Ensure login screen is visible by default
        document.addEventListener('DOMContentLoaded', function() {
            const loginContainer = document.querySelector('.login-container');
            const dashboard = document.getElementById('dashboard');
            if (loginContainer) loginContainer.style.display = 'flex';
            if (dashboard) dashboard.style.display = 'none';
            
            // TEMPORARY: Resize window to 1.5x height for debug panel visibility
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 630);
            }
        });

        // Check initial auth status
        if (window.electronAPI) {
            window.electronAPI.getAuthStatus().then(({ isAuthenticated: authenticated, user }) => {
                updateUI(authenticated, user);
            }).catch(err => {
                // Fallback to showing login screen
                updateUI(false, null);
            });

            // Listen for auth status changes
            window.electronAPI.onAuthStatusChanged(({ isAuthenticated: authenticated, user }) => {
                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none'; // Hide loading on any auth change
                updateUI(authenticated, user);
            });

            // Listen for mode changes (dashboard/interview)
            window.electronAPI.onModeChanged(({ mode, sessionData }) => {
                if (mode === 'interview') {
                    isInterviewModeInitializing = true;
                }
                handleModeChange(mode, sessionData);
            });

            // Listen for AI response chunks (streaming)
            window.electronAPI.onAIResponseChunk((chunk) => {
                if (currentStreamingMessageId && streamingMessages.has(currentStreamingMessageId)) {
                    // Get the current content for this specific message and append the chunk
                    const currentContent = streamingMessages.get(currentStreamingMessageId);
                    const updatedContent = currentContent + chunk;
                    streamingMessages.set(currentStreamingMessageId, updatedContent);
                    
                    // Check if we're using the expanded AI response area
                    const aiResponseArea = document.getElementById('interviewAIResponseArea');
                    if (aiResponseArea && aiResponseArea.style.display !== 'none' && 
                        (currentStreamingMessageId.includes('ai-expand') || currentStreamingMessageId.includes('ai-screen'))) {
                        // For auto AI, preserve the question header
                        let questionHeader = '';
                        if (currentStreamingMessageId.includes('ai-expand')) {
                            // Auto AI - look for existing question header
                            const contentEl = document.getElementById('aiResponseContent');
                            const existingContent = contentEl ? contentEl.innerHTML : '';
                            const questionMatch = existingContent.match(/<div[^>]*>.*?Question detected:.*?<\/div>/);
                            questionHeader = questionMatch ? questionMatch[0] : '';
                        } else if (currentStreamingMessageId.includes('ai-screen')) {
                            // Screen analysis - look for different pattern
                            const contentEl = document.getElementById('aiResponseContent');
                            const existingContent = contentEl ? contentEl.innerHTML : '';
                            const questionMatch = existingContent.match(/<div[^>]*>.*?Question detected:.*?<\/div>/);
                            questionHeader = questionMatch ? questionMatch[0] : '';
                        }
                        
                        // Update with question header (if any) + rendered markdown content with star emoji
                        const renderedContent = renderMarkdown(updatedContent);
                        updateAIResponseContentLegacy(questionHeader + '<div class="ai-markdown-content"><span style="font-size: 18px;">â­</span> ' + renderedContent + '</div>');
                    } else {
                        // Use the normal chat update for other messages
                        updateInterviewChatMessage(currentStreamingMessageId, updatedContent);
                    }
                }
            });

            // Listen for session timer updates
            window.electronAPI.onSessionTimerUpdate((timerData) => {
                const timerElement = document.getElementById('sessionTimerInterview');
                if (timerElement && timerData && timerData.display) {
                    // Always use the display format from main.ts
                    timerElement.textContent = timerData.display;
                    
                    // Add visual warning when time is running low
                    if (timerData.type === 'free' && timerData.remainingSeconds && timerData.remainingSeconds < 60) {
                        timerElement.style.color = '#ef4444'; // Red when under 1 minute
                    } else if (timerData.type === 'paid' && timerData.remaining && timerData.remaining < 5) {
                        timerElement.style.color = '#ef4444'; // Red when under 5 minutes for paid
                    } else {
                        timerElement.style.color = 'white'; // Normal color
                    }
                } else {
                }
            });

        } else {
            // Show login screen when electronAPI is not available
            updateUI(false, null);
        }

        function updateUI(authenticated, user) {
            // Don't show normal UI if interview mode is being initialized
            if (isInterviewModeInitializing) {
                return;
            }
            
            isAuthenticated = authenticated;
            currentUser = user;

            const loginScreen = document.getElementById('loginScreen');
            const loginContainer = document.querySelector('.login-container');
            const dashboard = document.getElementById('dashboard');
            const loading = document.getElementById('loading');

            // Hide loading
            if (loading) loading.style.display = 'none';

            if (authenticated) {
                if (loginContainer) loginContainer.style.display = 'none';
                if (dashboard) {
                    dashboard.style.display = 'flex';
                    dashboard.style.flexDirection = 'column';
                }
                
                // Resize window to dashboard size after login
                if (window.electronAPI && window.electronAPI.resizeWindow) {
                    window.electronAPI.resizeWindow(450, 240);
                }
                
                // Update user info and load real data
                if (user) {
                    const userName = document.getElementById('userName');
                    const userEmail = document.getElementById('userEmail');
                    if (userName) userName.textContent = user.name || 'User';
                    if (userEmail) userEmail.textContent = user.email || 'user@example.com';
                    
                    // Update user avatar with first letter of name
                    const userAvatar = document.querySelector('#userInfo div:first-child');
                    if (userAvatar) {
                        userAvatar.textContent = (user.name || 'U').charAt(0).toUpperCase();
                    }
                }
                
                // Load real user data and sessions
                loadUserData();
                loadSessions();
            } else {
                if (loginContainer) loginContainer.style.display = 'flex';
                if (dashboard) dashboard.style.display = 'none';
                
                // Resize window back to login screen size on logout (temporary 1.5x height for debug)
                if (window.electronAPI && window.electronAPI.resizeWindow) {
                    window.electronAPI.resizeWindow(450, 630);
                }
            }
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            if (tabName === 'create') {
                document.getElementById('createTab').classList.add('active');
                // Resize window for Create tab - compact height for session options
                if (window.electronAPI && window.electronAPI.resizeWindow) {
                    window.electronAPI.resizeWindow(450, 240);
                }
            } else if (tabName === 'sessions') {
                document.getElementById('sessionsTab').classList.add('active');
                // Resize window for Past Sessions tab - original perfect height
                if (window.electronAPI && window.electronAPI.resizeWindow) {
                    window.electronAPI.resizeWindow(450, 320);
                }
            }
        }

        function toggleMenu() {
            const dropdown = document.getElementById('menuDropdown');
            dropdown.classList.toggle('show');
        }

        async function collapseToLogo() {
            try {
                const result = await window.electronAPI.collapseToLogo();
                if (!result.success) {
                }
            } catch (error) {
            }
        }
        
        function closeApp() {
            if (window.electronAPI && window.electronAPI.closeApp) {
                window.electronAPI.closeApp();
            } else {
                window.close();
            }
        }

        function buyCredits() {
            if (window.electronAPI) {
                window.electronAPI.openExternal('https://www.chiku-ai.in/pricing');
            }
        }

        function createSession() {
            if (window.electronAPI) {
                window.electronAPI.openExternal('https://www.chiku-ai.in/dashboard');
            }
        }

        function handleActionButton() {
            // This will be set based on user's subscription tier
            const actionBtn = document.getElementById('actionBtn');
            if (actionBtn && actionBtn.textContent.includes('Create Session')) {
                showPaidResumeSelection();
            } else {
                buyCredits();
            }
        }

        function showPaidResumeSelection() {
            // Hide dashboard and show resume selection screen
            document.getElementById('dashboard').style.display = 'none';
            document.getElementById('resumeSelectionScreen').style.display = 'flex';
            
            // Resize window for resume selection content
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 650);
            }
            
            // Set flag for paid session
            window.isPaidSession = true;
            
            // Update the continue button to call paid session function
            const continueBtn = document.querySelector('.continue-btn');
            if (continueBtn) {
                continueBtn.setAttribute('onclick', 'continueWithPaidSession()');
            }
            
            // Load resumes when screen opens
            loadResumes();
        }

        async function showFreeSession() {
            // Check if user is in cooldown first
            try {
                if (window.electronAPI) {
                    const cooldownResponse = await window.electronAPI.checkCooldownStatus();
                    if (cooldownResponse.success && cooldownResponse.isInCooldown) {
                        // User is in cooldown, show alert and don't proceed
                        const remainingTime = cooldownResponse.cooldownInfo?.display || 'unknown time';
                        alert(`Free session is on cooldown. Please wait ${remainingTime} before starting another session.`);
                        return;
                    }
                }
            } catch (error) {
            }
            
            showResumeSelection();
        }

        function openDashboard() {
            if (window.electronAPI) {
                window.electronAPI.openExternal('https://www.chiku-ai.in/dashboard');
            }
        }

        function viewAllSessions() {
            if (window.electronAPI) {
                window.electronAPI.openExternal('https://www.chiku-ai.in/dashboard/interviewSessions');
            }
        }

        async function loadUserData() {
            try {
                if (window.electronAPI) {
                    const response = await window.electronAPI.fetchUserData();
                    if (response.success && response.user) {
                        const user = response.user;
                        
                        // Update credits display
                        const creditsCount = document.getElementById('creditsCount');
                        if (creditsCount) {
                            if (user.subscriptionTier === 'free') {
                                creditsCount.textContent = `${user.remainingMinutes || 0} / 10 min`;
                            } else {
                                creditsCount.textContent = `${user.remainingMinutes || 0} minutes`;
                            }
                        }

                        // Update action button based on subscription tier
                        const actionBtn = document.getElementById('actionBtn');
                        if (actionBtn) {
                            if (user.subscriptionTier !== 'free') {
                                // Paid plan - show Create Session button
                                actionBtn.textContent = 'Create Session';
                                actionBtn.style.background = '#c8894a'; // Orange background for create session
                            } else {
                                // Free plan - show Buy Credits button
                                actionBtn.textContent = 'Buy Credits';
                                actionBtn.style.background = '#374151'; // Dark gray background for buy credits
                            }
                        }
                        
                        // Check cooldown status for free users
                        if (user.subscriptionTier === 'free') {
                            await checkAndDisplayCooldown(user);
                        }
                    }
                }
            } catch (error) {
            }
        }

        let cooldownTimer = null;

        async function checkAndDisplayCooldown(userData = null) {
            try {
                if (window.electronAPI) {
                    // Use userData if provided, otherwise fetch from API
                    let userInfo = userData;
                    if (!userInfo) {
                        const userDataResponse = await window.electronAPI.fetchUserData();
                        if (userDataResponse.success) {
                            userInfo = userDataResponse.user;
                        }
                    }
                    
                    if (userInfo && userInfo.subscriptionTier === 'free') {
                        const cooldownNotification = document.getElementById('cooldownNotification');
                        const freeSessionOption = document.querySelector('.session-option');
                        
                        const now = new Date();
                        const remainingMinutes = userInfo.remainingMinutes || 0;
                        const freeMinutesResetAt = userInfo.freeMinutesResetAt ? new Date(userInfo.freeMinutesResetAt) : null;
                        const freeMinutesExhaustedAt = userInfo.freeMinutesExhaustedAt ? new Date(userInfo.freeMinutesExhaustedAt) : null;
                        
                        // Determine if user is in cooldown
                        const isInCooldown = remainingMinutes === 0 && freeMinutesResetAt && now < freeMinutesResetAt;
                        
                        const headerCooldownTimer = document.getElementById('headerCooldownTimer');
                        
                        if (remainingMinutes === 0) {
                            
                            // Hide the yellow banner (we don't want it anymore)
                            if (cooldownNotification) {
                                cooldownNotification.classList.remove('show');
                            }
                            
                            // Show header cooldown timer
                            if (headerCooldownTimer) {
                                headerCooldownTimer.classList.add('show');
                            }
                            
                            // Disable free session option
                            if (freeSessionOption) {
                                freeSessionOption.classList.add('cooldown-disabled');
                                freeSessionOption.onclick = null; // Disable click
                                freeSessionOption.innerHTML = 'Free Session (Cooldown)';
                            }
                            
                            // Start cooldown timer in header
                            if (isInCooldown && freeMinutesResetAt) {
                                startHeaderCooldownTimer(freeMinutesResetAt);
                            } else {
                                // User has 0 minutes but no active cooldown timer from server
                                if (headerCooldownTimer) {
                                    headerCooldownTimer.textContent = "(next session)";
                                }
                            }
                        } else {
                            // Hide cooldown timer from header
                            if (headerCooldownTimer) {
                                headerCooldownTimer.classList.remove('show');
                            }
                            
                            // Hide yellow banner
                            if (cooldownNotification) {
                                cooldownNotification.classList.remove('show');
                            }
                            
                            // Enable free session option
                            if (freeSessionOption) {
                                freeSessionOption.classList.remove('cooldown-disabled');
                                freeSessionOption.onclick = () => showFreeSession(); // Re-enable click
                                freeSessionOption.innerHTML = 'Free Session';
                            }
                            
                            // Clear any existing cooldown timer
                            if (cooldownTimer) {
                                clearInterval(cooldownTimer);
                                cooldownTimer = null;
                            }
                        }
                    }
                }
            } catch (error) {
            }
        }

        function startCooldownTimer(cooldownInfo) {
            // Clear any existing timer
            if (cooldownTimer) {
                clearInterval(cooldownTimer);
            }
            
            const cooldownTimerElement = document.getElementById('cooldownTimer');
            const resetAt = new Date(cooldownInfo.resetAt);
            
            cooldownTimer = setInterval(async () => {
                const now = new Date();
                const remainingMs = resetAt.getTime() - now.getTime();
                
                if (remainingMs <= 0) {
                    // Cooldown expired, refresh the status
                    clearInterval(cooldownTimer);
                    cooldownTimer = null;
                    await checkAndDisplayCooldown();
                    return;
                }
                
                const remainingMinutes = Math.floor(remainingMs / (1000 * 60));
                const remainingSeconds = Math.floor((remainingMs % (1000 * 60)) / 1000);
                
                if (cooldownTimerElement) {
                    cooldownTimerElement.textContent = `${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function startHeaderCooldownTimer(resetAt) {
            // Clear any existing timer
            if (cooldownTimer) {
                clearInterval(cooldownTimer);
            }
            
            const headerCooldownTimer = document.getElementById('headerCooldownTimer');
            const resetDate = new Date(resetAt);
            
            cooldownTimer = setInterval(async () => {
                const now = new Date();
                const remainingMs = resetDate.getTime() - now.getTime();
                
                if (remainingMs <= 0) {
                    // Cooldown expired, refresh the status
                    clearInterval(cooldownTimer);
                    cooldownTimer = null;
                    await checkAndDisplayCooldown();
                    return;
                }
                
                const remainingMinutes = Math.floor(remainingMs / (1000 * 60));
                const remainingSeconds = Math.floor((remainingMs % (1000 * 60)) / 1000);
                
                if (headerCooldownTimer) {
                    headerCooldownTimer.textContent = `(${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')})`;
                }
            }, 1000);
        }
        
        function startCooldownTimerWithResetAt(resetAt) {
            // Clear any existing timer
            if (cooldownTimer) {
                clearInterval(cooldownTimer);
            }
            
            const cooldownTimerElement = document.getElementById('cooldownTimer');
            const resetDate = new Date(resetAt);
            
            cooldownTimer = setInterval(async () => {
                const now = new Date();
                const remainingMs = resetDate.getTime() - now.getTime();
                
                if (remainingMs <= 0) {
                    // Cooldown expired, refresh the status
                    clearInterval(cooldownTimer);
                    cooldownTimer = null;
                    await checkAndDisplayCooldown();
                    return;
                }
                
                const remainingMinutes = Math.floor(remainingMs / (1000 * 60));
                const remainingSeconds = Math.floor((remainingMs % (1000 * 60)) / 1000);
                
                if (cooldownTimerElement) {
                    cooldownTimerElement.textContent = `${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        async function loadSessions() {
            try {
                if (window.electronAPI) {
                    const response = await window.electronAPI.fetchSessions();
                    if (response.success && response.sessions && response.sessions.length > 0) {
                        // Show only first 2 sessions for desktop app
                        const sessions = response.sessions.slice(0, 2);
                        
                        const sessionsList = document.getElementById('sessionsList');
                        sessionsList.innerHTML = sessions.map(session => {
                            const date = new Date(session.createdAt);
                            const formattedDate = date.toLocaleDateString('en-US', { 
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric'
                            });
                            
                            const companyInitial = (session.company || 'C').charAt(0).toUpperCase();
                            
                            return `
                                <div class="session-item">
                                    <div class="session-info">
                                        <div class="session-avatar">${companyInitial}</div>
                                        <div class="session-details">
                                            <div style="font-weight: 500; color: #1f2937; margin-bottom: 2px;">${session.company}</div>
                                            <div style="font-size: 12px; color: #6b7280;">${session.position}</div>
                                        </div>
                                    </div>
                                    <div class="session-date">${formattedDate}</div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        // Show empty state when no sessions
                        const sessionsList = document.getElementById('sessionsList');
                        sessionsList.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 40px; font-size: 14px;">No interview sessions yet</div>';
                    }
                }
            } catch (error) {
                // Show error state
                const sessionsList = document.getElementById('sessionsList');
                if (sessionsList) {
                    sessionsList.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 40px; font-size: 14px;">Unable to load sessions</div>';
                }
            }
        }

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('menuDropdown');
            const menuBtn = document.querySelector('.menu-btn');
            
            if (!menu.contains(event.target) && event.target !== menuBtn) {
                menu.classList.remove('show');
            }
        });

        // TEMPORARY DEBUG FUNCTIONS FOR AUTO-UPDATER
        function updateDebugStatus(status, info = '') {
            const statusEl = document.getElementById('updateStatus');
            const lastCheckEl = document.getElementById('lastCheck');
            const updateInfoEl = document.getElementById('updateInfo');
            
            if (statusEl) statusEl.textContent = status;
            if (lastCheckEl) lastCheckEl.textContent = new Date().toLocaleTimeString();
            if (updateInfoEl) updateInfoEl.textContent = info;
        }

        // Make function global and add debugging
        window.manualUpdateCheck = async function() {
            console.log('Manual check button clicked!'); // Debug log
            const infoEl = document.getElementById('updateInfo');
            updateDebugStatus('Checking manually...', 'User clicked manual check...');
            
            if (infoEl) {
                infoEl.innerHTML = '<div style="color: #c8894a;">ðŸ” Manual check started...</div><div style="color: #666;">Calling electron API...</div>';
            }

            try {
                // Check if electronAPI exists
                if (typeof window.electronAPI === 'undefined') {
                    throw new Error('window.electronAPI is undefined');
                }
                
                if (!window.electronAPI.checkForUpdates) {
                    throw new Error('electronAPI.checkForUpdates method not found');
                }
                
                console.log('Calling checkForUpdates...'); // Debug log
                const result = await window.electronAPI.checkForUpdates();
                console.log('Update check result:', result); // Debug log
                
                // Get more details about what the updater is seeing
                const currentVersion = await window.electronAPI.getAppVersion();
                console.log('Current app version:', currentVersion);
                
                updateDebugStatus('Manual check done', `Result: ${JSON.stringify(result, null, 2)}`);
                
                if (infoEl) {
                    infoEl.innerHTML = `<div style="color: #22c55e;">âœ… Manual check completed</div><div style="color: #666; font-family: monospace; white-space: pre-wrap; margin-top: 4px;">${JSON.stringify(result, null, 2)}</div>`;
                }
            } catch (error) {
                console.error('Manual check error:', error); // Debug log
                updateDebugStatus('Manual check failed', `Error: ${error.message}`);
                
                if (infoEl) {
                    infoEl.innerHTML = `<div style="color: #ef4444;">âŒ Manual check failed</div><div style="color: #666; margin-top: 4px;">Error: ${error.message}</div><div style="color: #999; margin-top: 2px;">Stack: ${error.stack || 'No stack trace'}</div>`;
                }
            }
        }

        // Install update function
        window.installUpdate = async function() {
            try {
                await window.electronAPI.quitAndInstall();
            } catch (error) {
                console.error('Install update failed:', error);
            }
        }

        // Set up auto-updater debug listeners
        if (window.electronAPI) {
            window.electronAPI.onUpdateAvailable((info) => {
                updateDebugStatus('Update Available!', `Version: ${info.version}`);
            });

            window.electronAPI.onUpdateDownloaded((info) => {
                updateDebugStatus('Update Downloaded!', `Ready to install: ${info.version}`);
                // Show install button when update is ready
                const installBtn = document.getElementById('installUpdateBtn');
                if (installBtn) {
                    installBtn.style.display = 'block';
                }
            });

            window.electronAPI.onDownloadProgress((progress) => {
                updateDebugStatus('Downloading...', `${progress.percent.toFixed(1)}%`);
            });
        }

        // Initial status update and force info box to show something
        setTimeout(() => {
            updateDebugStatus('Listening for updates', 'Auto-updater initialized');
            // Force the info box to show something immediately
            const infoEl = document.getElementById('updateInfo');
            if (infoEl) {
                infoEl.innerHTML = '<div style="color: #c8894a;">âœ“ Debug panel loaded</div><div style="color: #666; margin-top: 2px;">Auto-updater events are being monitored...</div>';
            }
        }, 1000);

        // Also initialize immediately when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(async () => {
                // Get and display actual app version
                try {
                    const version = await window.electronAPI.getAppVersion();
                    const versionEl = document.getElementById('appVersion');
                    if (versionEl) {
                        versionEl.textContent = version;
                    }
                } catch (error) {
                    const versionEl = document.getElementById('appVersion');
                    if (versionEl) {
                        versionEl.textContent = 'Error';
                    }
                }

                // Update info box
                const infoEl = document.getElementById('updateInfo');
                if (infoEl) {
                    infoEl.innerHTML = '<div style="color: #c8894a;">âœ“ DOM Ready</div><div style="color: #666; margin-top: 2px;">Waiting for auto-updater events...</div>';
                }
            }, 500);
        });

        async function login() {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';

            try {
                await window.electronAPI.login();
                // Note: Don't hide loading here - let the auth callback handle it
            } catch (error) {
                loading.style.display = 'none';
            }
        }

        async function logout() {
            try {
                await window.electronAPI.logout();
            } catch (error) {
            }
        }

        // Resume Selection Functions
        let currentResumes = [];
        let selectedResumeId = null;

        function showResumeSelection() {
            // Hide dashboard and show resume selection screen
            document.getElementById('dashboard').style.display = 'none';
            document.getElementById('resumeSelectionScreen').style.display = 'flex';
            
            // Resize window for resume selection content
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 650);
            }
            
            // Set flag for free session
            window.isPaidSession = false;
            
            // Update the continue button to call free session function
            const continueBtn = document.querySelector('.continue-btn');
            if (continueBtn) {
                continueBtn.setAttribute('onclick', 'continueWithResume()');
            }
            
            // Load resumes when screen opens
            loadResumes();
        }

        function closeResumeSelection() {
            // Hide resume selection screen and show dashboard
            document.getElementById('resumeSelectionScreen').style.display = 'none';
            document.getElementById('dashboard').style.display = 'flex';
            document.getElementById('dashboard').style.flexDirection = 'column';
            
            // Resize window back to dashboard size (Create tab is default)
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 280);
            }
        }

        async function loadResumes() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            const resumesList = document.getElementById('resumesList');
            const noResumesState = document.getElementById('noResumesState');
            
            // Show loading
            loadingSpinner.style.display = 'block';
            resumesList.innerHTML = '';
            noResumesState.style.display = 'none';
            
            try {
                if (window.electronAPI) {
                    const response = await window.electronAPI.fetchResumes();
                    
                    if (response.success && response.resumes && response.resumes.length > 0) {
                        currentResumes = response.resumes;
                        renderResumesList();
                    } else {
                        // Show no resumes state
                        noResumesState.style.display = 'block';
                        updateContinueButton();
                    }
                }
            } catch (error) {
                // Show no resumes state on error
                noResumesState.style.display = 'block';
                updateContinueButton();
            } finally {
                loadingSpinner.style.display = 'none';
            }
        }

        function renderResumesList() {
            const resumesList = document.getElementById('resumesList');
            
            resumesList.innerHTML = currentResumes.map(resume => {
                const uploadDate = new Date(resume.uploadedAt).toLocaleDateString();
                
                return `
                    <div class="resume-item ${selectedResumeId === resume._id ? 'selected' : ''}" 
                         onclick="toggleResumeSelection('${resume._id}')">
                        <input type="radio" 
                               name="resumeSelection" 
                               value="${resume._id}"
                               ${selectedResumeId === resume._id ? 'checked' : ''}
                               class="resume-radio">
                        <div class="resume-info">
                            <div class="resume-filename">${resume.fileName}</div>
                            <div class="resume-details">
                                Uploaded ${uploadDate}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            updateContinueButton();
        }

        function toggleResumeSelection(resumeId) {
            // If clicking the same resume, deselect it
            if (selectedResumeId === resumeId) {
                selectedResumeId = null;
            } else {
                selectedResumeId = resumeId;
            }
            
            // Update visual selection for all items
            document.querySelectorAll('.resume-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Update radio buttons
            document.querySelectorAll('input[name="resumeSelection"]').forEach(radio => {
                radio.checked = radio.value === selectedResumeId;
            });
            
            // Add selected class to current selection
            if (selectedResumeId) {
                const selectedItem = document.querySelector(`input[value="${selectedResumeId}"]`).closest('.resume-item');
                if (selectedItem) {
                    selectedItem.classList.add('selected');
                }
            }
            
            updateContinueButton();
        }

        function updateContinueButton() {
            const continueBtn = document.querySelector('.continue-btn');
            if (selectedResumeId) {
                continueBtn.textContent = 'Continue with Selected Resume';
            } else {
                continueBtn.textContent = 'Continue without Resume';
            }
        }

        function addNewResume() {
            // Open web dashboard for resume management
            if (window.electronAPI) {
                window.electronAPI.openExternal('https://www.chiku-ai.in/dashboard/resumes');
            }
        }

        function continueWithResume() {
            // Store session data for later use
            const company = document.getElementById('companyInput').value || 'Demo Company';
            const position = document.getElementById('positionInput').value || 'Demo Position';
            const autoAnswer = document.getElementById('autoAnswerCheckbox').checked;
            
            // Store in global variables for the activation screen
            window.sessionData = {
                company: company,
                position: position,
                autoAnswer: autoAnswer,
                resumeId: selectedResumeId
            };
            
            // Update activation screen for free session (this function is called from Free Session)
            updateActivationScreen(true);
            
            // Show session activation screen
            document.getElementById('resumeSelectionScreen').style.display = 'none';
            document.getElementById('sessionActivationScreen').style.display = 'flex';
            
            // Resize window for activation screen content
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 450);
            }
        }

        function continueWithPaidSession() {
            // Store session data for later use
            const company = document.getElementById('companyInput').value || 'Demo Company';
            const position = document.getElementById('positionInput').value || 'Demo Position';
            const autoAnswer = document.getElementById('autoAnswerCheckbox').checked;
            
            // Store in global variables for the activation screen
            window.sessionData = {
                company: company,
                position: position,
                autoAnswer: autoAnswer,
                resumeId: selectedResumeId
            };
            
            // Update activation screen for paid session
            updateActivationScreen(false);
            
            // Show session activation screen
            document.getElementById('resumeSelectionScreen').style.display = 'none';
            document.getElementById('sessionActivationScreen').style.display = 'flex';
            
            // Resize window for activation screen content
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 450);
            }
        }

        function updateActivationScreen(isFreeSession) {
            const activateButton = document.getElementById('activateButton');
            const sessionTimerText = document.querySelector('.session-timer-text');
            const sessionWarningText = document.querySelector('.session-warning-text');
            
            if (isFreeSession) {
                activateButton.textContent = 'Activate (Free)';
                sessionTimerText.textContent = 'This is a 10 minute free session.';
                sessionWarningText.textContent = "You won't be able to create another free session for the next 12 minutes.";
            } else {
                activateButton.textContent = 'Create Session';
                sessionTimerText.textContent = 'This is a paid session.';
                sessionWarningText.textContent = 'Session will use your available credits/minutes.';
            }
        }

        // Session Activation Screen Functions
        function backToResumeSelection() {
            document.getElementById('sessionActivationScreen').style.display = 'none';
            document.getElementById('resumeSelectionScreen').style.display = 'flex';
            
            // Resize window back to resume selection size
            if (window.electronAPI && window.electronAPI.resizeWindow) {
                window.electronAPI.resizeWindow(450, 650);
            }
        }

        function openExampleVideo() {
            if (window.electronAPI) {
                window.electronAPI.openExternal('https://youtu.be/mkYYh3ahOZM');
            }
        }

        async function activateSession() {
            // Get the session data
            const sessionData = window.sessionData;
            
            
            try {
                // Start interview session (transform window)
                const result = await window.electronAPI.startInterviewSession(sessionData);
                
                if (result.success) {
                    // Don't hide activation screen here - let handleModeChange do it
                } else {
                    alert('Failed to start interview session. Please try again.');
                }
            } catch (error) {
                alert('Failed to start interview session. Please try again.');
            }
        }

        // Handle mode changes between dashboard and interview
        function handleModeChange(mode, sessionData) {
            const interviewOverlay = document.getElementById('interviewOverlay');
            const loginContainer = document.querySelector('.login-container');
            const dashboard = document.getElementById('dashboard');
            const resumeSelectionScreen = document.getElementById('resumeSelectionScreen');
            const sessionActivationScreen = document.getElementById('sessionActivationScreen');

            if (mode === 'interview') {
                // Set body class for transparent background
                document.body.classList.add('interview-mode');
                
                // Hide all dashboard elements and show interview overlay
                if (loginContainer) loginContainer.style.display = 'none';
                if (dashboard) dashboard.style.display = 'none';
                if (resumeSelectionScreen) resumeSelectionScreen.style.display = 'none';
                if (sessionActivationScreen) sessionActivationScreen.style.display = 'none';
                if (interviewOverlay) {
                    interviewOverlay.style.display = 'flex';
                    initializeInterviewSession(sessionData);
                }
            } else if (mode === 'dashboard') {
                // Remove body class for normal background
                document.body.classList.remove('interview-mode');
                
                // Hide interview overlay and show dashboard
                if (interviewOverlay) interviewOverlay.style.display = 'none';
                
                // Show appropriate dashboard screen based on auth status
                if (isAuthenticated) {
                    if (dashboard) {
                        dashboard.style.display = 'flex';
                        dashboard.style.flexDirection = 'column';
                    }
                    
                    // Resize window back to dashboard size (Create tab is default)
                    if (window.electronAPI && window.electronAPI.resizeWindow) {
                        window.electronAPI.resizeWindow(450, 240);
                    }
                    
                    // Refresh user data and check cooldown when returning to dashboard
                    setTimeout(async () => {
                        await loadUserData();
                        await loadSessions();
                    }, 500); // Small delay to ensure UI is ready
                } else {
                    if (loginContainer) loginContainer.style.display = 'flex';
                }
            }
        }

        // Interview mode variables
        let currentInterviewSessionData = null;
        let currentResumeData = null; // Store fetched resume data for AI context
        let isTranscribing = false;
        let assemblyAISocket = null;
        let isAutoAnswerEnabled = false;
        let answeredQuestions = new Set();
        let currentStreamingMessageId = null;
        let streamingMessages = new Map(); // Track content per message ID
        let transcriptSegments = [];
        let audioContext = null;
        let mediaStream = null;
        let currentTranscripts = [];

        async function initializeInterviewSession(sessionData) {
            currentInterviewSessionData = sessionData;
            
            // Fetch resume data if resumeId is provided
            if (sessionData.resumeId) {
                try {
                    const resumeResponse = await window.electronAPI.fetchResumeById(sessionData.resumeId);
                    if (resumeResponse.success) {
                        currentResumeData = resumeResponse.resume;
                        addInterviewChatMessage('system', `ðŸ“„ Resume loaded: ${currentResumeData.fileName}`);
                    } else {
                        addInterviewChatMessage('system', 'âš ï¸ Failed to load selected resume');
                    }
                } catch (error) {
                    addInterviewChatMessage('system', 'âš ï¸ Error loading resume data');
                }
            } else {
                currentResumeData = null;
            }
            
            // Set Auto AI state from session data
            isAutoAnswerEnabled = sessionData.autoAnswer || false;
            
            // Add welcome message with session info
            addInterviewChatMessage('system', `Interview session started for ${sessionData.position} at ${sessionData.company}. Good luck!`);
            if (isAutoAnswerEnabled) {
                addInterviewChatMessage('system', 'ðŸ¤– Auto AI Answer is enabled - questions will be automatically answered.');
            }
            updateConnectionStatus('connecting', 'Requesting permissions...');
            
            // Initialize transparency controls
            initializeTransparencyControls();
            
            // Initialize Auto AI toggle
            initializeAutoAIToggle();
            
            // Initialize status indicators
            await initializeStatusIndicators();
            
            // Request permissions and start transcription
            await requestPermissionsAndStartTranscription();
        }

        // Helper function to build AI context with resume data (like webapp)
        function buildAIContextMessage(baseMessage) {
            let contextMessage = baseMessage;
            
            // Add resume context if available (similar to webapp implementation)
            if (currentResumeData) {
                contextMessage += `\n\nCONTEXT FROM RESUME:
Name: ${currentResumeData.personalDetails?.fullName || 'Not provided'}
Email: ${currentResumeData.personalDetails?.email || 'Not provided'}
Phone: ${currentResumeData.personalDetails?.phone || 'Not provided'}
Location: ${currentResumeData.personalDetails?.location || 'Not provided'}

Introduction: ${currentResumeData.introduction || 'Not provided'}

Education: ${JSON.stringify(currentResumeData.education) || 'Not provided'}

Job Experience: ${JSON.stringify(currentResumeData.jobExperience) || 'Not provided'}

Other Experience: ${JSON.stringify(currentResumeData.otherExperience) || 'Not provided'}`;
            }
            
            return contextMessage;
        }

        async function requestPermissionsAndStartTranscription() {
            try {
                // Request microphone permission
                await requestMicrophonePermission();
                
                // Request screen permission
                await requestScreenPermission();
                
                // Start audio transcription
                await startTranscription();
                
            } catch (error) {
                addInterviewChatMessage('system', 'Error setting up transcription. Please check your microphone permissions.');
            }
        }

        async function requestMicrophonePermission() {
            try {
                updateConnectionStatus('connecting', 'Requesting microphone permission...');
                
                // The permission will be handled by getUserMedia call
                // Just update status to indicate we're ready to try
                updateMicrophoneStatus(false); // Start as false, will update when actually connected
                
                return { success: true };
            } catch (error) {
                updateMicrophoneStatus(false);
                addInterviewChatMessage('system', 'Microphone permission denied. Click the microphone button to try again.');
                return { success: false, error: error.message };
            }
        }

        async function requestScreenPermission() {
            try {
                
                // Simple approach: just try to get sources and let system handle permissions
                const sourcesResult = await window.electronAPI.getDesktopSources();
                
                if (sourcesResult.success && sourcesResult.sources.length > 0) {
                    updateScreenShareStatus(true);
                    window.screenSourceId = sourcesResult.sources[0].id;
                } else {
                    updateScreenShareStatus(false);
                    addInterviewChatMessage('system', 'ðŸ“º Screen recording not available. Permission may be needed.');
                }
                
                return { success: true };
            } catch (error) {
                updateScreenShareStatus(false);
                addInterviewChatMessage('system', `ðŸ“º Screen recording error: ${error.message}`);
                return { success: false, error: error.message };
            }
        }

        async function startTranscription() {
            try {
                if (isTranscribing) return;
                
                updateConnectionStatus('connecting', 'Starting transcription service...');
                
                // Get AssemblyAI token
                const tokenResponse = await window.electronAPI.getAssemblyAIToken();
                if (!tokenResponse.success) {
                    throw new Error(tokenResponse.error);
                }
                
                // Get microphone access
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                        },
                    });

                    const audioTracks = mediaStream.getAudioTracks();

                    // Update microphone status when successfully connected
                    if (mediaStream && audioTracks.length > 0) {
                        actualMicrophonePermission = true;
                        updateMicrophoneStatus(true);
                    } else {
                        actualMicrophonePermission = true; // Permission granted but no tracks
                        addInterviewChatMessage('system', 'Microphone access granted but no audio tracks available.');
                        updateMicrophoneStatus(false);
                        return;
                    }
                } catch (micError) {
                    actualMicrophonePermission = false; // Permission denied
                    addInterviewChatMessage('system', `âŒ Microphone access failed: ${micError.name} - ${micError.message}`);
                    updateMicrophoneStatus(false);
                    return;
                }

                // Create WebSocket connection to AssemblyAI
                assemblyAISocket = new WebSocket(
                    `wss://streaming.assemblyai.com/v3/ws?sample_rate=16000&encoding=pcm_s16le&format_turns=true&token=${tokenResponse.token}`
                );

                assemblyAISocket.onopen = () => {
                    isTranscribing = true;
                    transcriptState.isConnected = true;
                    transcriptState.isRecording = true;
                    updateConnectionStatus('connected', 'Connected - Start speaking!');
                    startAudioProcessing();
                    
                    // Hide status after a delay to show transcripts
                    setTimeout(() => {
                        transcriptState.hasStarted = true;
                        updateConnectionStatus('connected', 'Connected - Start speaking!');
                    }, 2000);
                    
                    // Apply transparency after everything is working
                    setTimeout(() => {
                        updateTransparency(95);
                    }, 1000); // Wait 1 second for everything to settle
                };

                assemblyAISocket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        
                        
                        if (message.transcript !== undefined) {
                            if (message.end_of_turn) {
                                // End of turn - finalize transcript
                                // With format_turns=true, we get two messages per turn:
                                // 1. Unformatted (turn_is_formatted: false)  
                                // 2. Formatted (turn_is_formatted: true)
                                // Only add the formatted version to avoid duplicates
                                if (message.turn_is_formatted && message.transcript) {
                                    currentTranscripts.push({
                                        id: crypto.randomUUID(),
                                        text: message.transcript,
                                        timestamp: new Date(),
                                    });
                                    // Convert existing partial to final instead of adding new item
                                    finalizeCurrentPartial(message.transcript);
                                    
                                    // Check for Auto AI answer if enabled
                                    
                                    if (isAutoAnswerEnabled && message.transcript.trim()) {
                                        analyzeTranscriptForQuestions(message.transcript);
                                    } else if (!isAutoAnswerEnabled) {
                                    } else {
                                    }
                                    
                                    // Save complete transcript periodically (every 5 turns to avoid excessive saves)
                                    if (currentInterviewSessionData?.sessionId && currentTranscripts.length % 5 === 0) {
                                        const fullTranscript = currentTranscripts.map(t => t.text).join(' ');
                                        window.electronAPI.saveTranscript(currentInterviewSessionData.sessionId, fullTranscript)
                                            .catch(error => {
                                            });
                                    }
                                } else if (message.end_of_turn) {
                                    // DON'T clear partial element here - wait for formatted version
                                }
                            } else {
                                // Partial transcript (still being spoken) - exactly like webapp
                                addInterviewTranscriptItem(message.transcript || '', true);
                            }
                        }

                        if (message.type === 'Error') {
                            updateConnectionStatus('error', `Error: ${message.error}`);
                        }
                    } catch (e) {
                    }
                };

                assemblyAISocket.onerror = (event) => {
                    addInterviewChatMessage('system', `âŒ WebSocket error occurred - check connection`);
                    transcriptState.isConnected = false;
                    updateConnectionStatus('error', 'Connection error occurred');
                };

                assemblyAISocket.onclose = (event) => {
                    isTranscribing = false;
                    transcriptState.isConnected = false;
                    transcriptState.isRecording = false;
                    if (event.code !== 1000 && event.code !== 1005) {
                        updateConnectionStatus('error', `Connection closed: ${event.reason || `Code ${event.code}`}`);
                    }
                };

            } catch (error) {
                updateConnectionStatus('error', `Failed to start: ${error.message}`);
                // Update microphone status on error
                updateMicrophoneStatus(false);
            }
        }

        async function startAudioProcessing() {
            audioContext = new AudioContext({ sampleRate: 16000 });
            const source = audioContext.createMediaStreamSource(mediaStream);

            // Create AudioWorklet processor inline to avoid external files
            const processorCode = `
                class TranscriptionProcessor extends AudioWorkletProcessor {
                    constructor() {
                        super();
                        this.bufferSize = 2048;
                        this.buffer = new Float32Array(this.bufferSize);
                        this.bufferIndex = 0;
                    }
                    
                    process(inputs, outputs, parameters) {
                        const input = inputs[0];
                        if (input.length > 0) {
                            const inputChannel = input[0];
                            
                            for (let i = 0; i < inputChannel.length; i++) {
                                this.buffer[this.bufferIndex] = inputChannel[i];
                                this.bufferIndex++;
                                
                                if (this.bufferIndex >= this.bufferSize) {
                                    // Send buffer to main thread
                                    this.port.postMessage({
                                        type: 'audioBuffer',
                                        buffer: this.buffer.slice()
                                    });
                                    this.bufferIndex = 0;
                                }
                            }
                        }
                        return true; // Keep processor alive
                    }
                }
                
                registerProcessor('transcription-processor', TranscriptionProcessor);
            `;

            // Create blob URL for the processor
            const blob = new Blob([processorCode], { type: 'application/javascript' });
            const processorUrl = URL.createObjectURL(blob);

            // Load the AudioWorklet module
            await audioContext.audioWorklet.addModule(processorUrl);

            // Create AudioWorklet node
            const workletNode = new AudioWorkletNode(audioContext, 'transcription-processor');

            // Handle messages from the processor
            workletNode.port.onmessage = (event) => {
                if (event.data.type === 'audioBuffer' && assemblyAISocket && assemblyAISocket.readyState === WebSocket.OPEN) {
                    const pcm16 = convertFloat32ToPCM16(event.data.buffer);
                    assemblyAISocket.send(pcm16.buffer);
                }
            };

            // Connect source to worklet (no need to connect to destination!)
            source.connect(workletNode);
            
            // Clean up blob URL
            URL.revokeObjectURL(processorUrl);
        }

        function convertFloat32ToPCM16(float32Array) {
            const pcm16 = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
            }
            return pcm16;
        }

        function stopTranscription() {
            if (assemblyAISocket) {
                assemblyAISocket.send(JSON.stringify({ type: 'Terminate' }));
                assemblyAISocket.close();
                assemblyAISocket = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
                // Update microphone status when stream is stopped
                updateMicrophoneStatus(false);
            }

            isTranscribing = false;
        }

        async function stopInterviewSession() {
            try {
                // Stop transcription
                stopTranscription();
                
                // Save final complete transcript before ending session
                if (currentInterviewSessionData?.sessionId && currentTranscripts.length > 0) {
                    const fullTranscript = currentTranscripts.map(t => t.text).join(' ');
                    await window.electronAPI.saveTranscript(currentInterviewSessionData.sessionId, fullTranscript)
                        .catch(error => {
                            console.error('Failed to save final transcript:', error);
                        });
                }
                
                // End interview session (restore to dashboard)
                const result = await window.electronAPI.endInterviewSession();
                
                if (result.success) {
                    addInterviewChatMessage('system', 'Session ended. Thank you for using Chiku AI!');
                } else {
                }
            } catch (error) {
            }
        }

        function addInterviewChatMessage(type, content, messageId = null) {
            const messagesContainer = document.getElementById('interviewChatMessages');
            
            if (!messagesContainer) {
                return null;
            }
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `interview-chat-message ${type}-message`;
            if (messageId) {
                messageDiv.id = messageId;
            }
            
            const renderedContent = renderMarkdown(content);
            
            if (type === 'ai') {
                messageDiv.innerHTML = `
                    <div><strong>AI:</strong> ${renderedContent}</div>
                    <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">${timestamp}</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div>${renderedContent}</div>
                    <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">${timestamp}</div>
                `;
            }
            
            try {
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } catch (error) {
                return null;
            }
            
            return messageDiv;
        }

        function updateInterviewChatMessage(messageId, content) {
            const messageDiv = document.getElementById(messageId);
            if (messageDiv) {
                const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const renderedContent = renderMarkdown(content);
                
                if (messageDiv.classList.contains('ai-message')) {
                    messageDiv.innerHTML = `
                        <div><strong>AI:</strong> ${renderedContent}</div>
                        <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">${timestamp}</div>
                    `;
                } else {
                    messageDiv.innerHTML = `
                        <div>${renderedContent}</div>
                        <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">${timestamp}</div>
                    `;
                }
                
                const messagesContainer = document.getElementById('interviewChatMessages');
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        let currentPartialElement = null;
        let transcriptState = {
            isConnected: false,
            isRecording: false,
            hasStarted: false
        };

        function updateConnectionStatus(status, text) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectionStatus = document.getElementById('connectionStatus');
            
            // Remove all status classes
            statusIndicator.className = 'interview-status-indicator';
            statusIndicator.classList.add(status);
            statusText.textContent = text;
            
            // Show/hide connection status based on state
            if (transcriptState.hasStarted && transcriptState.isConnected) {
                connectionStatus.style.display = 'none';
            } else {
                connectionStatus.style.display = 'flex';
            }
        }

        function finalizeCurrentPartial(finalText) {
            if (currentPartialElement) {
                // Convert partial to final by removing blue styling and cursor
                const textElement = currentPartialElement.querySelector('.interview-transcript-text');
                textElement.className = 'interview-transcript-text'; // Remove partial class
                textElement.innerHTML = finalText; // Remove cursor and update text
                currentPartialElement = null;
            } else {
                // No partial element exists, create new final transcript
                addInterviewTranscriptItem(finalText, false);
            }
        }

        // Simple syntax highlighter - applies highlighting to already HTML-escaped content
        function applySyntaxHighlighting(escapedCode, language) {
            if (!language) return escapedCode;
            
            const lang = language.toLowerCase();
            let highlighted = escapedCode;
            
            if (lang === 'python') {
                // First escape HTML entities that are in the code
                highlighted = highlighted
                    .replace(/\b(def|class|if|else|elif|for|while|try|except|import|from|return|yield|with|as|lambda|pass|break|continue|global|nonlocal|assert|del|raise|True|False|None|and|or|not|in|is)\b/g, '<span class="keyword">$1</span>')
                    .replace(/(#.*$)/gm, '<span class="comment">$1</span>')
                    .replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="function">$1</span>(');
            } else if (lang === 'javascript' || lang === 'js') {
                highlighted = highlighted
                    .replace(/\b(function|var|let|const|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|new|this|typeof|instanceof|true|false|null|undefined)\b/g, '<span class="keyword">$1</span>')
                    .replace(/(\/\/.*$)/gm, '<span class="comment">$1</span>')
                    .replace(/\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g, '<span class="function">$1</span>(');
            } else if (lang === 'java') {
                highlighted = highlighted
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|extends|implements|import|package|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|true|false|null|void|int|long|short|byte|char|boolean|float|double|String)\b/g, '<span class="keyword">$1</span>')
                    .replace(/(\/\/.*$)/gm, '<span class="comment">$1</span>')
                    .replace(/\b([A-Z][a-zA-Z0-9_]*)\b/g, '<span class="class">$1</span>');
            }
            
            return highlighted;
        }

        // Simplified markdown renderer with better code block handling
        function renderMarkdown(text) {
            if (!text) return '';
            
            let processedText = text.trim();
            
            // Handle triple backtick code blocks first
            processedText = processedText.replace(/```(\w+)?\s*\n([\s\S]*?)\n?```/g, (match, language, code) => {
                const cleanCode = code.trim();
                const escapedCode = cleanCode
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                return `\n<div class="code-block-container"><div class="code-block-header">${language || 'code'}</div><pre class="code-block"><code>${escapedCode}</code></pre></div>\n`;
            });
            
            // Handle single backtick with language (like `python)
            processedText = processedText.replace(/`(\w+)\s*\n([\s\S]*?)(?=\n\n|\n#|\n\*|$)/g, (match, language, code) => {
                const cleanCode = code.trim();
                const escapedCode = cleanCode
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                return `\n<div class="code-block-container"><div class="code-block-header">${language}</div><pre class="code-block"><code>${escapedCode}</code></pre></div>\n`;
            });
            
            // Handle inline code (single backticks)
            processedText = processedText.replace(/`([^`\n]+)`/g, (match, code) => {
                const escapedCode = code
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                return `<code class="inline-code">${escapedCode}</code>`;
            });
            
            // Handle headers
            processedText = processedText.replace(/^## (.+)$/gm, '<h2 class="markdown-h2">$1</h2>');
            processedText = processedText.replace(/^# (.+)$/gm, '<h1 class="markdown-h1">$1</h1>');
            
            // Handle bold and italic
            processedText = processedText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Handle line breaks and paragraphs
            processedText = processedText.replace(/\n/g, '<br>');
            
            return processedText;
        }

        // Auto AI Answer Functions
        async function analyzeTranscriptForQuestions(transcript) {
            
            const questionKeywords = [
                'what', 'how', 'why', 'when', 'where', 'who', 'which', 'would you', 
                'can you', 'could you', 'tell me', 'describe', 'explain', 'share',
                'what are', 'what is', 'how do', 'why did', 'can you tell',
                'can you walk', 'walk me through', 'talk about', 'thoughts on'
            ];

            const normalizedTranscript = transcript.toLowerCase().trim();
            
            // Skip very short transcripts (likely incomplete)
            if (normalizedTranscript.length < 10) {
                return;
            }
            
            // Check if it's likely a question
            const endsWithQuestionMark = normalizedTranscript.endsWith('?');
            const containsQuestionKeywords = questionKeywords.some(keyword => 
                normalizedTranscript.includes(keyword.toLowerCase())
            );
            
            
            if (endsWithQuestionMark || containsQuestionKeywords) {
                const questionHash = btoa(transcript).substring(0, 10);
                
                
                if (!answeredQuestions.has(questionHash)) {
                    answeredQuestions.add(questionHash);
                    
                    // Add slight delay to feel natural
                    setTimeout(() => {
                        autoAnswerQuestion(transcript);
                    }, 1500);
                } else {
                }
            } else {
            }
        }

        async function autoAnswerQuestion(transcriptText) {
            
            try {
                // Extract the actual question from the transcript
                const extractedQuestion = extractBestQuestion(transcriptText);
                const questionToShow = extractedQuestion || transcriptText.substring(0, 100) + '...';
                
                
                // Show AI response area (same as manual AI Answer button)
                showAIResponseArea();
                
                // Create a unique message ID for streaming
                const messageId = `ai-expand-${Date.now()}`;
                currentStreamingMessageId = messageId;
                
                // Debug logging disabled
                
                // Show initial loading with extracted question
                const initialContent = `<div style="color: #f59e0b; font-weight: 600; margin-bottom: 12px;"><span style="font-size: 18px;">â˜ï¸</span> Question detected: ${questionToShow}</div><div class="ai-loading"><div class="ai-loading-spinner"></div>Generating AI answer...</div>`;
                updateAIResponseContentLegacy(initialContent);
                
                // Initialize streaming content (empty to avoid duplication)
                streamingMessages.set(messageId, '');
                
                // Build context message similar to manual AI Answer
                let baseContextMessage = `You are responding as the interviewee in a job interview${currentInterviewSessionData?.company && currentInterviewSessionData?.position ? ` for the position of ${currentInterviewSessionData.position} at ${currentInterviewSessionData.company}` : ''}. Provide a direct, professional response that the candidate can read word-for-word to answer this question: "${extractedQuestion || transcriptText}". 

IMPORTANT: 
- Give ONLY the response the interviewee should say, not advice about what to say
- Make it sound natural and conversational, as if spoken by a real person
- Keep it concise but complete (2-4 sentences max)
- Do not use bullet points or markdown formatting
- Do not start with phrases like "Here's a professional response" or "You should say"
- Just give the direct answer the person should speak${currentInterviewSessionData?.company && currentInterviewSessionData?.position ? `\n- Tailor your response to the ${currentInterviewSessionData.position} role at ${currentInterviewSessionData.company}` : ''}`;

                // Add resume context to the message
                const contextMessage = buildAIContextMessage(baseContextMessage);
                
                // Debug logging disabled
                
                // Use streaming API (same as manual AI Answer)
                const response = await window.electronAPI.generateAIResponseStream({
                    transcript: '',
                    message: contextMessage,
                    isCoding: false
                });
                
                // Debug logging disabled
                
                // Cleanup streaming state
                streamingMessages.delete(messageId);
                currentStreamingMessageId = null;
                
            } catch (error) {
                // Debug logging disabled
                
                // Show error in AI response area
                const errorContent = `<div style="color: #f59e0b; font-weight: 600; margin-bottom: 12px;"><span style="font-size: 18px;">â˜ï¸</span> Question detected: ${questionToShow}</div><div style="color: #ef4444;">âŒ Auto AI failed: ${error.message}</div><div style="margin-top: 8px; opacity: 0.7;">Please use the manual AI Answer button to try again.</div>`;
                updateAIResponseContentLegacy(errorContent);
                
                // Cleanup
                if (currentStreamingMessageId) {
                    streamingMessages.delete(currentStreamingMessageId);
                }
                currentStreamingMessageId = null;
            }
        }

        function updateLastAIMessage(newContent) {
            
            const chatContainer = document.getElementById('interviewChatMessages');
            if (!chatContainer) {
                return;
            }
            
            const messages = chatContainer.querySelectorAll('.interview-chat-message');
            const lastMessage = messages[messages.length - 1];
            
            
            if (lastMessage && lastMessage.classList.contains('ai-message')) {
                const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                lastMessage.innerHTML = `
                    <div><strong>AI:</strong> ${newContent}</div>
                    <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">${timestamp}</div>
                `;
            } else {
            }
        }

        function addInterviewTranscriptItem(text, isPartial = false, timestamp = null) {
            // Since we removed the transcript container, we only need to update the compact display
            // and maintain the transcripts array for AI processing
            
            if (!isPartial && text && text.trim()) {
                // Store the final transcript in our array
                const transcriptEntry = {
                    text: text.trim(),
                    timestamp: timestamp || new Date().toISOString()
                };
                
                // Add to currentTranscripts array for AI processing
                if (window.currentTranscripts) {
                    window.currentTranscripts.push(transcriptEntry);
                } else {
                    window.currentTranscripts = [transcriptEntry];
                }
            }
            
            // Update compact transcript display
            updateCompactTranscriptDisplay(text, isPartial);
        }
        
        function updateCompactTranscriptDisplay(text, isPartial = false) {
            const latestTranscriptText = document.getElementById('latestTranscriptText');
            if (latestTranscriptText && text && text.trim()) {
                if (isPartial) {
                    // Show partial transcript in blue with blinking cursor
                    latestTranscriptText.innerHTML = text + '<span style="color: #3b82f6; animation: blink 1s infinite;">|</span>';
                    latestTranscriptText.style.color = '#3b82f6'; // Blue color for partial text
                } else {
                    // Show final transcript in white
                    latestTranscriptText.innerHTML = text;
                    latestTranscriptText.style.color = 'white';
                }
            }
        }

        function showAIResponseArea() {
            const aiResponseArea = document.getElementById('interviewAIResponseArea');
            if (aiResponseArea) {
                aiResponseArea.style.display = 'block';
                // Resize main window to accommodate AI response area  
                resizeInterviewWindow(520); // 120 base + 400 AI response
            }
        }

        function closeAIResponse() {
            const aiResponseArea = document.getElementById('interviewAIResponseArea');
            if (aiResponseArea) {
                aiResponseArea.style.display = 'none';
                // Hide pagination controls
                const paginationControls = document.getElementById('aiPaginationControls');
                if (paginationControls) paginationControls.style.display = 'none';
                // Resize back to original compact size
                resizeInterviewWindow(120);
            }
        }

        // AI Response Pagination System
        let aiResponses = []; // Store up to 3 responses
        let currentResponseIndex = 0;
        let isUpdatingCurrentResponse = false; // Flag to prevent duplicate adds during streaming

        function addAIResponse(content, question = '') {
            // If we're currently updating the most recent response, just update its content
            if (isUpdatingCurrentResponse && aiResponses.length > 0) {
                aiResponses[0].content = content;
                updateAIResponseContent(content);
                return;
            }
            
            // Check for exact duplicate
            if (aiResponses.length > 0 && aiResponses[0].content === content) {
                return;
            }
            
            const response = {
                content: content,
                question: question,
                timestamp: Date.now(),
                id: 'response-' + Date.now()
            };
            
            // Add to beginning of array
            aiResponses.unshift(response);
            
            // Keep only latest 3 responses
            if (aiResponses.length > 3) {
                const removedResponse = aiResponses.pop();
            }
            
            // Reset to first response
            currentResponseIndex = 0;
            
            // Mark that we're updating this response (for streaming)
            isUpdatingCurrentResponse = true;
            
            // Clear the flag after a delay (when streaming is likely done)
            setTimeout(() => {
                isUpdatingCurrentResponse = false;
            }, 2000);
            
            // Update UI
            updateAIResponseContent(content);
            updatePaginationUI();
        }

        function navigateAIResponse(direction) {
            if (aiResponses.length <= 1) {
                return;
            }
            
            const newIndex = currentResponseIndex + direction;
            
            if (newIndex >= 0 && newIndex < aiResponses.length) {
                currentResponseIndex = newIndex;
                updatePaginationUI();
                updateAIResponseContent(aiResponses[currentResponseIndex].content);
            }
        }

        function updatePaginationUI() {
            const paginationControls = document.getElementById('aiPaginationControls');
            const prevBtn = document.getElementById('aiPrevBtn');
            const nextBtn = document.getElementById('aiNextBtn');
            const pageIndicator = document.getElementById('aiPageIndicator');
            
            // Only show pagination if we have more than 1 response
            if (paginationControls) {
                if (aiResponses.length > 1) {
                    paginationControls.style.display = 'flex';
                    if (prevBtn) {
                        prevBtn.disabled = currentResponseIndex === 0;
                    }
                    if (nextBtn) {
                        nextBtn.disabled = currentResponseIndex === aiResponses.length - 1;
                    }
                    if (pageIndicator) {
                        pageIndicator.textContent = `${currentResponseIndex + 1} / ${aiResponses.length}`;
                    }
                } else {
                    paginationControls.style.display = 'none';
                }
            }
        }

        function updateAIResponseContent(content) {
            const aiContent = document.getElementById('aiResponseContent');
            if (aiContent) {
                aiContent.innerHTML = content;
            }
        }
        
        // Legacy function that now uses the pagination system
        function updateAIResponseContentLegacy(content) {
            // For loading states, update directly without adding to history
            if (content.includes('ai-loading') || content.includes('Error') || content.includes('disabled')) {
                updateAIResponseContent(content);
            } else {
                // For actual responses, add to pagination system
                addAIResponse(content);
            }
        }

        
        // Initialize pagination system
        document.addEventListener('DOMContentLoaded', function() {
            // Hide pagination controls initially
            const paginationControls = document.getElementById('aiPaginationControls');
            if (paginationControls) {
                paginationControls.style.display = 'none';
            }
        });

        async function resizeInterviewWindow(newHeight) {
            // Send resize request to main process
            try {
                await window.electronAPI.resizeInterviewWindow(1200, newHeight);
            } catch (error) {
                console.error('Failed to resize window:', error);
            }
        }

        // Function to extract the most recent question from transcript
        function extractRecentQuestion(transcript) {
            if (!transcript || !transcript.trim()) return null;
            
            const sentences = transcript.split(/[.!]/).map(s => s.trim()).filter(s => s.length > 0);
            
            // Look for questions (ending with ?) first
            const questions = sentences.filter(s => s.endsWith('?'));
            if (questions.length > 0) {
                return questions[questions.length - 1];
            }
            
            // Look for question keywords
            const questionKeywords = ['what', 'how', 'why', 'when', 'where', 'who', 'which', 'would you', 'can you', 'could you', 'tell me', 'describe', 'explain'];
            
            for (let i = sentences.length - 1; i >= 0; i--) {
                const sentence = sentences[i].toLowerCase();
                if (questionKeywords.some(keyword => sentence.includes(keyword))) {
                    return sentences[i];
                }
            }
            
            // Return the last sentence if no clear question is found
            return sentences.length > 0 ? sentences[sentences.length - 1] : null;
        }

        // Improved question extraction using better logic
        function extractBestQuestion(transcript) {
            if (!transcript || !transcript.trim()) return null;
            
            // Split by sentence endings and question marks
            const segments = transcript.split(/[.!?]/).map(s => s.trim()).filter(s => s.length > 5);
            
            // Look for explicit questions first (ending with ?)
            const explicitQuestions = [];
            const parts = transcript.split('?');
            for (let i = 0; i < parts.length - 1; i++) {
                const question = parts[i].trim();
                const lastSentence = question.split(/[.!]/).pop().trim();
                if (lastSentence.length > 5) {
                    explicitQuestions.push(lastSentence + '?');
                }
            }
            
            if (explicitQuestions.length > 0) {
                return explicitQuestions[explicitQuestions.length - 1];
            }
            
            // Enhanced question keywords with common interview patterns
            const questionKeywords = [
                'what', 'how', 'why', 'when', 'where', 'who', 'which', 'whose',
                'would you', 'can you', 'could you', 'will you', 'do you',
                'tell me', 'describe', 'explain', 'share', 'talk about',
                'what are', 'what is', 'what do', 'how do', 'why did', 'why do',
                'can you tell', 'can you walk', 'walk me through', 'thoughts on'
            ];
            
            // Look for question-like sentences
            for (let i = segments.length - 1; i >= 0; i--) {
                const segment = segments[i].toLowerCase();
                if (questionKeywords.some(keyword => segment.includes(keyword))) {
                    return segments[i];
                }
            }
            
            // Fall back to the last meaningful segment
            return segments.length > 0 ? segments[segments.length - 1] : null;
        }

        async function handleAIAnswerInterview() {
            const btn = document.getElementById('aiAnswerBtnInterview');
            btn.classList.add('active');
            
            try {
                // Show AI response area and resize window
                showAIResponseArea();
                
                // Get current transcript
                const fullTranscript = currentTranscripts ? currentTranscripts.map(t => t.text).join(' ') : '';
                
                if (!fullTranscript.trim()) {
                    updateAIResponseContentLegacy('<div class="ai-loading"><div class="ai-loading-spinner"></div>No transcript available yet. Please speak first.</div>');
                    btn.classList.remove('active');
                    return;
                }

                // Extract the most recent question using improved logic
                const recentQuestion = extractBestQuestion(fullTranscript);
                
                // Always show loading state - if question found, show it; otherwise show generic message
                if (recentQuestion) {
                    updateAIResponseContentLegacy(`<div style="color: #f59e0b; font-weight: 600; margin-bottom: 12px;"><span style="font-size: 18px;">â˜ï¸</span> Question detected: ${recentQuestion}</div><div class="ai-loading"><div class="ai-loading-spinner"></div>Generating professional answer...</div>`);
                } else {
                    // Try to extract any question-like content from transcript
                    const questionLikeContent = fullTranscript.split('.').pop().trim() || fullTranscript.substring(Math.max(0, fullTranscript.length - 100));
                    updateAIResponseContentLegacy(`<div style="color: #f59e0b; font-weight: 600; margin-bottom: 12px;"><span style="font-size: 18px;">â˜ï¸</span> Analyzing: ${questionLikeContent}${questionLikeContent.endsWith('?') ? '' : '...'}</div><div class="ai-loading"><div class="ai-loading-spinner"></div>Generating professional response...</div>`);
                }
                
                // Generate AI response using streaming transcript
                const baseMessage = `Extract the most recent question from this transcript and provide a professional interview answer: ${fullTranscript}`;
                const contextMessage = buildAIContextMessage(baseMessage);
                
                // Initialize streaming content - use the existing streaming system
                currentStreamingMessageId = `ai-expand-${Date.now()}`;
                streamingMessages.set(currentStreamingMessageId, '');
                
                const response = await window.electronAPI.generateAIResponseStream({
                    transcript: fullTranscript,
                    message: contextMessage,
                    isCoding: false
                });
                
                if (!response.success) {
                    updateAIResponseContentLegacy(`<div style="color: #ff6b6b;">Error generating AI answer: ${response.error}</div>`);
                } else {
                    // The streaming content will be handled by the existing onAIResponseChunk handler
                    // and updateInterviewChatMessage function. We need to redirect it to our AI response area.
                }
                
                // Cleanup streaming state
                streamingMessages.delete(currentStreamingMessageId);
                currentStreamingMessageId = null;
                
            } catch (error) {
                updateAIResponseContentLegacy(`<div style="color: #ff6b6b;">Error generating AI answer. Please try again.</div>`);
                if (currentStreamingMessageId) {
                    streamingMessages.delete(currentStreamingMessageId);
                    currentStreamingMessageId = null;
                }
            } finally {
                btn.classList.remove('active');
            }
        }

        async function handleAnalyzeScreenInterview() {
            const btn = document.getElementById('analyzeScreenBtnInterview');
            btn.classList.add('active');
            
            try {
                
                // Show AI response area and resize window
                showAIResponseArea();
                
                // Check if screen sharing is enabled
                if (!isScreenShareOn) {
                    updateAIResponseContentLegacy('<div style="color: #ffa500;">Screen sharing is disabled. Please enable it first to analyze screen.</div>');
                    btn.classList.remove('active');
                    return;
                }
                
                
                // Get screen source ID
                const sourceResult = await window.electronAPI.captureScreen();
                
                if (!sourceResult.success || !sourceResult.sourceId) {
                    updateAIResponseContentLegacy(`<div style="color: #ff6b6b;">Screen capture failed: ${sourceResult.error || 'Unknown error'}</div>`);
                    btn.classList.remove('active');
                    return;
                }

                // Take screenshot with getUserMedia (this will trigger permission dialog if needed)
                let imageData;
                try {
                    imageData = await takeScreenshotWithSource(sourceResult.sourceId);
                } catch (error) {
                    let errorMessage = `<div style="color: #ff6b6b;">âŒ Screenshot failed: ${error.name} - ${error.message}</div>`;
                    if (error.message.includes('Could not start video source') || error.message.includes('Permission denied')) {
                        errorMessage += '<div style="color: #ffa500; margin-top: 10px;">ðŸ”’ Screen recording permission needed</div>';
                        errorMessage += '<div style="color: #87ceeb; margin-top: 5px;">ðŸ’¡ In development mode, try: System Preferences > Privacy & Security > Screen Recording > Add Terminal.app</div>';
                        errorMessage += '<div style="color: #87ceeb; margin-top: 5px;">âœ… Or test in production build: npm run dist</div>';
                    }
                    updateAIResponseContentLegacy(errorMessage);
                    btn.classList.remove('active');
                    return;
                }

                // Show loading state
                updateAIResponseContentLegacy('<div class="ai-loading"><div class="ai-loading-spinner"></div>Analyzing screen content...</div>');
                
                // Analyze screen content
                const analysisResult = await window.electronAPI.analyzeScreenContent(imageData);
                
                
                if (analysisResult.success) {
                    if (analysisResult.question && analysisResult.question !== "No questions found on screen.") {
                        // Show question detected in AI response area
                        updateAIResponseContentLegacy(`<div style="color: #f59e0b; font-weight: 600; margin-bottom: 12px;"><span style="font-size: 18px;">â˜ï¸</span> Question detected: ${analysisResult.question}</div><div class="ai-loading"><div class="ai-loading-spinner"></div>Generating professional answer...</div>`);
                        
                        // Use the existing streaming system - use ai-screen prefix so the handler knows to update AI response area
                        currentStreamingMessageId = `ai-screen-${Date.now()}`;
                        streamingMessages.set(currentStreamingMessageId, '');
                        
                        // Generate AI answer based on detected question
                        const contextMessage = buildAIContextMessage(analysisResult.question);
                        const response = await window.electronAPI.generateAIResponseStream({
                            question: analysisResult.question,
                            message: contextMessage,
                            isCoding: analysisResult.isCoding || false
                        });
                        
                        if (!response.success) {
                            updateAIResponseContentLegacy(`<div style="color: #ff6b6b;">Error generating AI answer: ${response.error}</div>`);
                        }
                        
                        // Cleanup
                        streamingMessages.delete(currentStreamingMessageId);
                        currentStreamingMessageId = null;
                    } else {
                        updateAIResponseContentLegacy('<div style="color: #ffa500;">Screen analysis complete. No interview questions detected on screen.</div>');
                    }
                } else {
                    updateAIResponseContentLegacy(`<div style="color: #ff6b6b;">Screen analysis failed: ${analysisResult.error}</div>`);
                }
                
            } catch (error) {
                updateAIResponseContentLegacy(`<div style="color: #ff6b6b;">Error analyzing screen: ${error.message}</div>`);
                if (currentStreamingMessageId) {
                    streamingMessages.delete(currentStreamingMessageId);
                    currentStreamingMessageId = null;
                }
            } finally {
                btn.classList.remove('active');
            }
        }

        function toggleChatFocusInterview() {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.focus();
            }
        }

        // Chat History Management
        let chatHistory = [];
        
        function getLastAIResponses(count = 3) {
            const messagesContainer = document.getElementById('interviewChatMessages');
            const aiMessages = messagesContainer.querySelectorAll('.interview-chat-message.ai-message');
            const lastAIMessages = Array.from(aiMessages).slice(-count);
            return lastAIMessages.map(msg => {
                const content = msg.querySelector('div').textContent;
                return content.replace('AI: ', '').trim();
            });
        }
        
        function buildChatContext(userMessage) {
            const fullTranscript = currentTranscripts.map(t => t.text).join(' ');
            const lastAIResponses = getLastAIResponses(3);
            
            let contextMessage = `You are an AI assistant helping in a job interview session${currentInterviewSessionData?.company && currentInterviewSessionData?.position ? ` for the position of ${currentInterviewSessionData.position} at ${currentInterviewSessionData.company}` : ''}.\n\n`;
            
            // Add transcript context
            if (fullTranscript.trim()) {
                contextMessage += `Interview Transcript:\n${fullTranscript}\n\n`;
            }
            
            // Add recent AI responses for context
            if (lastAIResponses.length > 0) {
                contextMessage += `Recent AI Responses:\n`;
                lastAIResponses.forEach((response, index) => {
                    contextMessage += `${index + 1}. ${response}\n`;
                });
                contextMessage += '\n';
            }
            
            // Add resume context if available
            if (currentResumeData) {
                contextMessage += `Resume Context:\nCandidate's resume includes: ${currentResumeData.content?.substring(0, 500)}...\n\n`;
            }
            
            contextMessage += `User Question: ${userMessage}\n\nPlease provide a helpful, professional response that considers the interview context and any previous conversation.`;
            
            return contextMessage;
        }

        function handleChatInputKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleChatSend();
            }
        }

        async function handleChatSend() {
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');
            const userMessage = chatInput.value.trim();
            
            if (!userMessage) return;
            
            // Disable input and button
            chatInput.disabled = true;
            chatSendBtn.disabled = true;
            
            try {
                // Add user message to chat
                addInterviewChatMessage('user', userMessage);
                
                // Clear input
                chatInput.value = '';
                
                // Generate unique message ID for streaming
                const messageId = `ai-chat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                currentStreamingMessageId = messageId;
                streamingMessages.set(messageId, '');
                
                // Add empty AI message for streaming
                addInterviewChatMessage('ai', '', messageId);
                
                // Build context and generate streaming response
                const contextMessage = buildChatContext(userMessage);
                const response = await window.electronAPI.generateAIResponseStream({
                    message: contextMessage,
                    transcript: '',
                    isCoding: false
                });
                
                if (!response.success) {
                    updateInterviewChatMessage(messageId, `Error generating response: ${response.error}`);
                }
                
                // Cleanup streaming state
                streamingMessages.delete(messageId);
                currentStreamingMessageId = null;
                
            } catch (error) {
                if (currentStreamingMessageId) {
                    updateInterviewChatMessage(currentStreamingMessageId, 'Error generating response. Please try again.');
                    streamingMessages.delete(currentStreamingMessageId);
                }
                currentStreamingMessageId = null;
            } finally {
                // Re-enable input and button
                chatInput.disabled = false;
                chatSendBtn.disabled = false;
                chatInput.focus();
            }
        }

        // Auto AI Toggle Functions
        function toggleAutoAI(enabled) {
            // Debug logging disabled
            isAutoAnswerEnabled = enabled;
            
            // Clear answered questions when toggling to allow re-answering
            if (enabled) {
                answeredQuestions.clear();
                // Debug logging disabled
            } else {
                // Debug logging disabled
            }
        }

        // Initialize Auto AI toggle state when entering interview mode
        function initializeAutoAIToggle() {
            // Debug logging disabled
            
            const toggle = document.getElementById('autoAIToggleInterview');
            if (toggle) {
                // Sync with the global isAutoAnswerEnabled that was set from session data
                toggle.checked = isAutoAnswerEnabled;
                // Debug logging disabled
                
                // Update UI to reflect current state without triggering chat message
            } else {
                // Debug logging disabled
            }
        }

        // Transparency control functions
        function updateTransparency(value) {
            const transparencyValue = document.getElementById('transparencyValue');
            transparencyValue.textContent = value + '%';
            
            // Convert percentage to opacity (0.1 to 1.0)
            const opacity = value / 100;
            
            // Update only the overlay background opacity, not the entire window
            const interviewOverlay = document.getElementById('interviewOverlay');
            if (interviewOverlay) {
                const alpha = opacity * 0.95; // Keep some base opacity for the overlay
                interviewOverlay.style.background = `rgba(0, 0, 0, ${alpha})`;
            }
        }

        // Initialize transparency slider when entering interview mode
        function initializeTransparencyControls() {
            const slider = document.getElementById('transparencySlider');
            const value = document.getElementById('transparencyValue');
            
            if (slider && value) {
                // Set initial values but don't apply transparency yet
                slider.value = 95;
                value.textContent = '95%';
                // Don't call updateTransparency here - let it be applied manually
            }
        }

        // Panel resize functionality
        let isPanelExpanded = false;

        // Status tracking
        let isMicrophoneOn = false; // Start as false until actually connected
        let isScreenShareOn = false; // Start as false until actually connected
        let microphoneTracks = []; // Store actual audio tracks

        function togglePanelSizes() {
            const leftPanel = document.getElementById('interviewLeftPanel');
            const rightPanel = document.getElementById('interviewRightPanel');
            const resizeBtn = document.getElementById('panelResizeBtn');
            
            if (!leftPanel || !rightPanel || !resizeBtn) return;
            
            isPanelExpanded = !isPanelExpanded;
            
            if (isPanelExpanded) {
                // Expand left panel to 80%, shrink right panel to 20%
                leftPanel.classList.add('expanded');
                rightPanel.classList.add('collapsed');
                resizeBtn.classList.add('expanded');
                resizeBtn.innerHTML = 'â‡†';
                resizeBtn.title = 'Reset panel sizes';
            } else {
                // Reset to 50/50 split
                leftPanel.classList.remove('expanded');
                rightPanel.classList.remove('collapsed');
                resizeBtn.classList.remove('expanded');
                resizeBtn.innerHTML = 'â‡„';
                resizeBtn.title = 'Toggle panel sizes';
            }
        }

        // Permission status tracking
        let actualMicrophonePermission = false;
        let actualScreenSharePermission = false;
        
        // Check actual microphone permission status
        async function checkMicrophonePermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                actualMicrophonePermission = true;
                return true;
            } catch (error) {
                actualMicrophonePermission = false;
                return false;
            }
        }
        
        // Check actual screen sharing permission status
        async function checkScreenSharePermission() {
            try {
                const sourcesResult = await window.electronAPI.getDesktopSources();
                if (sourcesResult.success && sourcesResult.sources.length > 0) {
                    // Try to actually get screen capture permission
                    const testStream = await navigator.mediaDevices.getUserMedia({
                        audio: false,
                        video: {
                            mandatory: {
                                chromeMediaSource: 'desktop',
                                chromeMediaSourceId: sourcesResult.sources[0].id,
                                minWidth: 100,
                                maxWidth: 100,
                                minHeight: 100,
                                maxHeight: 100
                            }
                        }
                    });
                    testStream.getTracks().forEach(track => track.stop());
                    actualScreenSharePermission = true;
                    return true;
                }
                actualScreenSharePermission = false;
                return false;
            } catch (error) {
                actualScreenSharePermission = false;
                return false;
            }
        }

        // Status indicator functions
        function updateMicrophoneStatus(isOn) {
            isMicrophoneOn = isOn;
            const micBtn = document.getElementById('micStatusBtn');
            const micText = document.getElementById('micStatusText');
            
            if (!micBtn || !micText) return;
            
            micBtn.classList.remove('active', 'inactive', 'denied');
            
            if (!actualMicrophonePermission) {
                // Permission denied
                micBtn.classList.add('denied');
                micText.textContent = 'DENIED';
                micBtn.title = 'Microphone: Permission denied (click to request permission)';
            } else if (isOn) {
                micBtn.classList.add('active');
                micText.textContent = 'ON';
                micBtn.title = 'Microphone: ON (click to mute)';
            } else {
                micBtn.classList.add('inactive');
                micText.textContent = 'OFF';
                micBtn.title = 'Microphone: OFF (click to unmute)';
            }
        }

        function updateScreenShareStatus(isOn) {
            isScreenShareOn = isOn;
            const screenBtn = document.getElementById('screenStatusBtn');
            const screenText = document.getElementById('screenStatusText');
            
            if (!screenBtn || !screenText) return;
            
            screenBtn.classList.remove('active', 'inactive', 'denied');
            
            if (!actualScreenSharePermission) {
                // Permission denied
                screenBtn.classList.add('denied');
                screenText.textContent = 'DENIED';
                screenBtn.title = 'Screen Share: Permission denied (click to request permission)';
            } else if (isOn) {
                screenBtn.classList.add('active');
                screenText.textContent = 'ON';
                screenBtn.title = 'Screen Share: ON (click to stop)';
            } else {
                screenBtn.classList.add('inactive');
                screenText.textContent = 'OFF';
                screenBtn.title = 'Screen Share: OFF (click to start)';
            }
        }

        async function toggleMicrophone() {
            // Check actual permission first
            const hasPermission = await checkMicrophonePermission();
            
            if (!hasPermission) {
                // Permission denied, try to request it
                addInterviewChatMessage('system', 'ðŸŽ¤ Requesting microphone permission...');
                try {
                    await startTranscription();
                } catch (error) {
                        actualMicrophonePermission = false;
                    updateMicrophoneStatus(false);
                    addInterviewChatMessage('system', 'ðŸŽ¤ Microphone permission denied. Please enable in System Preferences and restart the app.');
                    return;
                }
                return;
            }
            
            if (!mediaStream || mediaStream.getAudioTracks().length === 0) {
                // Try to start transcription which will request microphone permission
                try {
                    await startTranscription();
                } catch (error) {
                        addInterviewChatMessage('system', 'ðŸŽ¤ Failed to access microphone. Please check permissions in system preferences.');
                }
                return;
            }

            const audioTracks = mediaStream.getAudioTracks();
            if (audioTracks.length === 0) {
                addInterviewChatMessage('system', 'ðŸŽ¤ No microphone tracks found');
                return;
            }

            const newState = !isMicrophoneOn;
            
            // Actually enable/disable the microphone tracks
            audioTracks.forEach(track => {
                track.enabled = newState;
            });
            
            updateMicrophoneStatus(newState);
            
            // Add system message to chat
            const statusMessage = newState ? 'Microphone unmuted' : 'Microphone muted';
            addInterviewChatMessage('system', `ðŸŽ¤ ${statusMessage}`);
        }

        async function toggleScreenShare() {
            try {
                const analyzeBtn = document.getElementById('analyzeScreenBtnInterview');
                
                // Check actual permission first
                const hasPermission = await checkScreenSharePermission();
                
                if (!hasPermission) {
                    // Permission denied
                    actualScreenSharePermission = false;
                    updateScreenShareStatus(false);
                    addInterviewChatMessage('system', 'ðŸ“º Screen recording permission denied. Please enable in System Preferences > Privacy & Security > Screen Recording and restart the app');
                    
                    // Disable the analyze screen button
                    if (analyzeBtn) {
                        analyzeBtn.disabled = true;
                        analyzeBtn.style.opacity = '0.5';
                        analyzeBtn.title = 'Screen recording permission denied';
                    }
                    return;
                }
                
                if (!isScreenShareOn) {
                    // Permission granted, enable screen sharing
                    actualScreenSharePermission = true;
                    updateScreenShareStatus(true);
                    
                    // Get screen sources for analysis
                    try {
                        const sourcesResult = await window.electronAPI.getDesktopSources();
                        if (sourcesResult && sourcesResult.success && sourcesResult.sources.length > 0) {
                            window.screenSourceId = sourcesResult.sources[0].id;
                        }
                    } catch (sourceError) {
                    }
                    
                    // Re-enable the analyze screen button
                    if (analyzeBtn) {
                        analyzeBtn.disabled = false;
                        analyzeBtn.style.opacity = '1';
                        analyzeBtn.title = 'Analyze Screen';
                    }
                } else {
                    // Disable screen sharing functionality
                    updateScreenShareStatus(false);
                    
                    // Disable the analyze screen button
                    if (analyzeBtn) {
                        analyzeBtn.disabled = true;
                        analyzeBtn.style.opacity = '0.5';
                        analyzeBtn.title = 'Screen recording is disabled';
                    }
                }
            } catch (error) {
                actualScreenSharePermission = false;
                updateScreenShareStatus(false);
                addInterviewChatMessage('system', 'ðŸ“º Screen recording error: ' + error.message);
            }
        }

        // Function to take a real screenshot using getUserMedia
        async function takeScreenshotWithSource(sourceId) {
            return new Promise(async (resolve, reject) => {
                try {
                    
                    // Use getUserMedia to capture the screen with the specific source
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: false,
                        video: {
                            mandatory: {
                                chromeMediaSource: 'desktop',
                                chromeMediaSourceId: sourceId,
                                minWidth: 1280,
                                maxWidth: 1920,
                                minHeight: 720,
                                maxHeight: 1080
                            }
                        }
                    });

                    
                    // Create video element to capture frame
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.autoplay = true;
                    video.muted = true;

                    video.onloadedmetadata = () => {
                        
                        // Wait a bit for the video to start
                        setTimeout(() => {
                            try {
                                // Create canvas to capture frame
                                const canvas = document.createElement('canvas');
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                                
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(video, 0, 0);
                                
                                // Convert to base64
                                const imageData = canvas.toDataURL('image/png');
                                
                                
                                // Stop the stream
                                stream.getTracks().forEach(track => track.stop());
                                
                                resolve(imageData);
                            } catch (error) {
                                stream.getTracks().forEach(track => track.stop());
                                reject(error);
                            }
                        }, 500); // Wait 500ms for video to fully load
                    };

                    video.onerror = (error) => {
                        stream.getTracks().forEach(track => track.stop());
                        reject(new Error('Failed to load video stream'));
                    };

                } catch (error) {
                    reject(error);
                }
            });
        }

        // Initialize status indicators when interview starts
        async function initializeStatusIndicators() {
            // Check actual permissions and set button states accordingly
            const micPermission = await checkMicrophonePermission();
            const screenPermission = await checkScreenSharePermission();
            
            
            // Update button states based on actual permissions
            updateMicrophoneStatus(false); // OFF initially, but will show DENIED if no permission
            updateScreenShareStatus(false); // OFF initially, but will show DENIED if no permission
        }


    </script>
</body>
</html>